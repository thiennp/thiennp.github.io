import type { Branded } from '../typeguards/isBranded';
/**
 * Predefined brand symbols for common use cases.
 *
 * These symbols can be used to create branded types with unique symbols,
 * providing better type safety and avoiding string literal conflicts.
 *
 * @example
 * ```typescript
 * import { Branded, isBranded, BrandSymbols } from 'guardz';
 *
 * type UserId = Branded<number, typeof BrandSymbols.UserId>;
 * type Email = Branded<string, typeof BrandSymbols.Email>;
 *
 * const isUserId = isBranded<UserId>((value) => {
 *   return typeof value === 'number' && value > 0 && Number.isInteger(value);
 * });
 *
 * const isEmail = isBranded<Email>((value) => {
 *   if (typeof value !== 'string') return false;
 *   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
 *   return emailRegex.test(value);
 * });
 * ```
 */
export declare const BrandSymbols: {
    readonly UserId: symbol;
    readonly Email: symbol;
    readonly Password: symbol;
    readonly Age: symbol;
    readonly PhoneNumber: symbol;
    readonly URL: symbol;
    readonly UUID: symbol;
    readonly Timestamp: symbol;
    readonly PositiveNumber: symbol;
    readonly NonEmptyString: symbol;
    readonly ApiResponse: symbol;
    readonly DatabaseId: symbol;
    readonly SessionToken: symbol;
    readonly FilePath: symbol;
    readonly Currency: symbol;
};
/**
 * Type for accessing predefined brand symbols.
 */
export type BrandSymbolsType = typeof BrandSymbols;
/**
 * Utility type to create branded types with predefined symbols.
 *
 * @template T - The base type
 * @template K - The key of the predefined brand symbol
 * @returns A branded type using the predefined brand symbol
 *
 * @example
 * ```typescript
 * import { BrandedWith } from 'guardz';
 *
 * type UserId = BrandedWith<number, 'UserId'>;
 * type Email = BrandedWith<string, 'Email'>;
 * ```
 */
export type BrandedWith<T, K extends keyof BrandSymbolsType> = Branded<T, BrandSymbolsType[K]>;
