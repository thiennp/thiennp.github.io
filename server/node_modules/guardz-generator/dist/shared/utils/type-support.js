"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.separatePropertiesBySupport = exports.isSupportedTypeGuard = exports.isSupportedProperty = exports.isSupportedType = void 0;
const ts = __importStar(require("typescript"));
/**
 * Checks if a type is supported for type guard generation
 * @param typeNode The TypeScript type node to check
 * @returns true if the type is supported, false otherwise
 */
const isSupportedType = (typeNode) => {
    if (ts.isParenthesizedTypeNode(typeNode)) {
        return (0, exports.isSupportedType)(typeNode.type);
    }
    if (ts.isUnionTypeNode(typeNode)) {
        // Union types are supported if all their constituents are supported
        return typeNode.types.every(type => (0, exports.isSupportedType)(type));
    }
    if (ts.isIntersectionTypeNode(typeNode)) {
        // Intersection types are supported if all their constituents are supported
        return typeNode.types.every(type => (0, exports.isSupportedType)(type));
    }
    if (ts.isTypeReferenceNode(typeNode)) {
        const typeName = typeNode.typeName.getText();
        // Check for primitive types
        if ([
            'string',
            'number',
            'boolean',
            'bigint',
            'any',
            'unknown',
            'null',
            'undefined',
            'object',
        ].includes(typeName)) {
            return true;
        }
        // Check for common type references that are supported
        if ([
            'Array',
            'Promise',
            'Date',
            'RegExp',
            'Error',
            'Map',
            'Set',
            'WeakMap',
            'WeakSet',
        ].includes(typeName)) {
            return true;
        }
        // Function types are not supported
        if (typeName === 'Function' || typeName.endsWith('Function')) {
            return false;
        }
        // For generic types, check if type arguments are supported
        if (typeNode.typeArguments) {
            return typeNode.typeArguments.every(arg => (0, exports.isSupportedType)(arg));
        }
        // Custom types are generally supported
        return true;
    }
    if (ts.isTypeLiteralNode(typeNode)) {
        // Check if this is a function type literal (has call signatures)
        const hasCallSignatures = typeNode.members.some(member => ts.isCallSignatureDeclaration(member));
        if (hasCallSignatures) {
            return false; // Function type literals are not supported
        }
        // Type literals are supported if all their properties are supported
        return typeNode.members.every(member => {
            if (ts.isPropertySignature(member) && member.type) {
                return (0, exports.isSupportedType)(member.type);
            }
            if (ts.isIndexSignatureDeclaration(member) && member.type) {
                return (0, exports.isSupportedType)(member.type);
            }
            if (ts.isMethodSignature(member)) {
                // Method signatures (function types) are not supported
                return false;
            }
            return true; // Other members are considered supported
        });
    }
    // Check for function type nodes (kind 184)
    if (typeNode.kind === 184) {
        return false; // Function types are not supported
    }
    if (ts.isTypeOperatorNode(typeNode)) {
        // Type operators like 'keyof', 'typeof' are generally not supported
        return false;
    }
    if (ts.isArrayTypeNode(typeNode)) {
        return (0, exports.isSupportedType)(typeNode.elementType);
    }
    if (ts.isTupleTypeNode(typeNode)) {
        return typeNode.elements.every(element => (0, exports.isSupportedType)(element));
    }
    if (ts.isLiteralTypeNode(typeNode)) {
        return true; // Literal types are supported
    }
    if (ts.isIndexedAccessTypeNode(typeNode)) {
        // Indexed access types are generally not supported
        return false;
    }
    // For primitive types, check the text
    const typeText = typeNode.getText();
    return [
        'string',
        'number',
        'boolean',
        'bigint',
        'any',
        'unknown',
        'null',
        'undefined',
        'object',
    ].includes(typeText);
};
exports.isSupportedType = isSupportedType;
/**
 * Checks if a property type is supported for type guard generation
 * @param property The property info to check
 * @returns true if the property type is supported, false otherwise
 */
const isSupportedProperty = (property) => {
    return (0, exports.isSupportedType)(property.type);
};
exports.isSupportedProperty = isSupportedProperty;
/**
 * Checks if a type guard string represents a supported type
 * @param typeGuard The type guard string to check
 * @returns true if the type guard represents a supported type, false otherwise
 */
const isSupportedTypeGuard = (typeGuard) => {
    // Types that are not supported (function types, etc.)
    const unsupportedGuards = ['isAsserted'];
    // Check if the type guard contains any unsupported patterns
    return !unsupportedGuards.some(guard => typeGuard.includes(guard));
};
exports.isSupportedTypeGuard = isSupportedTypeGuard;
/**
 * Separates properties into supported and unsupported groups
 * @param properties Array of property info
 * @returns Object with supported and unsupported property arrays
 */
const separatePropertiesBySupport = (properties) => {
    const supported = [];
    const unsupported = [];
    for (const property of properties) {
        if ((0, exports.isSupportedProperty)(property)) {
            supported.push(property);
        }
        else {
            unsupported.push(property);
        }
    }
    return { supported, unsupported };
};
exports.separatePropertiesBySupport = separatePropertiesBySupport;
//# sourceMappingURL=type-support.js.map