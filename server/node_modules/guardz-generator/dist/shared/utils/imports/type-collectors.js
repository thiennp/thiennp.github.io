"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAssertedTypesInCode = exports.isGuardzType = exports.needsTypeGuardFnConfig = exports.needsTypeGuardFn = exports.collectUsedGuardzTypeAliases = exports.collectUsedTypeGuards = exports.collectUsedGuardzUtilities = exports.collectUsedEnumsInCode = exports.collectReferencedTypesFromTypeAlias = exports.collectReferencedTypes = void 0;
const ts = __importStar(require("typescript"));
const types_1 = require("../types");
const import_extractors_1 = require("./import-extractors");
// Collect referenced types from interface declarations
const collectReferencedTypes = (interfaceDecl) => {
    const referencedTypes = new Set();
    // Collect base types from extends clause
    if (interfaceDecl.heritageClauses) {
        for (const heritageClause of interfaceDecl.heritageClauses) {
            for (const type of heritageClause.types) {
                const baseTypeName = type.expression.getText();
                referencedTypes.add(baseTypeName);
                // Also collect type arguments if any (e.g., extends Base<T>)
                if (type.typeArguments) {
                    type.typeArguments.forEach(typeArg => {
                        if (ts.isTypeReferenceNode(typeArg)) {
                            referencedTypes.add(typeArg.typeName.getText());
                        }
                    });
                }
            }
        }
    }
    const visit = (typeNode) => {
        if (!typeNode)
            return;
        if (ts.isTypeReferenceNode(typeNode) && typeNode.typeName) {
            const typeName = typeNode.typeName.getText();
            if (!typeName)
                return;
            // Check if this is a namespace-qualified type (e.g., 'ts.CompilerOptions')
            const namespaceInfo = (0, import_extractors_1.extractNamespaceFromQualifiedType)(typeName);
            if (namespaceInfo) {
                // For namespace-qualified types, we need to import the namespace, not the full type
                referencedTypes.add(namespaceInfo.namespace);
            }
            else {
                referencedTypes.add(typeName);
            }
            // Visit type arguments for generic types
            if (typeNode.typeArguments) {
                typeNode.typeArguments.forEach(visit);
            }
        }
        else if (ts.isUnionTypeNode(typeNode)) {
            typeNode.types.forEach(visit);
        }
        else if (ts.isIntersectionTypeNode(typeNode)) {
            typeNode.types.forEach(visit);
        }
        else if (ts.isArrayTypeNode(typeNode)) {
            visit(typeNode.elementType);
        }
        else if (ts.isTupleTypeNode(typeNode)) {
            typeNode.elements.forEach(visit);
        }
        else if (ts.isTypeLiteralNode(typeNode)) {
            typeNode.members.forEach(member => {
                if (ts.isPropertySignature(member) && member.type) {
                    visit(member.type);
                }
            });
        }
        else if (ts.isParenthesizedTypeNode(typeNode)) {
            visit(typeNode.type);
        }
    };
    // Visit all property types
    interfaceDecl.members.forEach(member => {
        if (ts.isPropertySignature(member) && member.type) {
            visit(member.type);
        }
    });
    return Array.from(referencedTypes).sort();
};
exports.collectReferencedTypes = collectReferencedTypes;
// Collect referenced types from type alias declarations
const collectReferencedTypesFromTypeAlias = (typeAliasDecl, sourceFiles) => {
    const referenced = new Set();
    referenced.add(typeAliasDecl.name.text);
    const visit = (typeNode) => {
        if (!typeNode)
            return;
        if (ts.isTypeReferenceNode(typeNode) && typeNode.typeName) {
            const typeName = typeNode.typeName.getText();
            if (!typeName)
                return;
            // Check if this is a namespace-qualified type (e.g., 'ts.CompilerOptions')
            const namespaceInfo = (0, import_extractors_1.extractNamespaceFromQualifiedType)(typeName);
            if (namespaceInfo) {
                // For namespace-qualified types, we need to import the namespace, not the full type
                referenced.add(namespaceInfo.namespace);
            }
            else {
                // Don't add enums to type imports since they're used at runtime
                // Don't add built-in types that don't need imports
                if (!(0, types_1.isEnumType)(typeName, sourceFiles) &&
                    !(0, types_1.isBuiltInType)(typeName) &&
                    !(0, types_1.isTypeAlias)(typeName)) {
                    referenced.add(typeName);
                }
            }
            if (typeNode.typeArguments) {
                typeNode.typeArguments.forEach(visit);
            }
        }
        else if (ts.isArrayTypeNode(typeNode)) {
            visit(typeNode.elementType);
        }
        else if (ts.isUnionTypeNode(typeNode)) {
            typeNode.types.forEach(visit);
        }
        else if (ts.isTypeLiteralNode(typeNode)) {
            typeNode.members.forEach((member) => {
                if (ts.isPropertySignature(member) && member.type) {
                    visit(member.type);
                }
            });
        }
    };
    visit(typeAliasDecl.type);
    return Array.from(referenced);
};
exports.collectReferencedTypesFromTypeAlias = collectReferencedTypesFromTypeAlias;
// Collect used enums in generated code
const collectUsedEnumsInCode = (typeGuardCode) => {
    const usedEnums = new Set();
    // Look for enum usage patterns like isEnum(EnumName)
    const enumPattern = /isEnum\(([A-Z][a-zA-Z0-9_]*)\)/g;
    let match;
    while ((match = enumPattern.exec(typeGuardCode)) !== null) {
        usedEnums.add(match[1]);
    }
    return Array.from(usedEnums);
};
exports.collectUsedEnumsInCode = collectUsedEnumsInCode;
// Collect used guardz utilities in generated code
const collectUsedGuardzUtilities = (typeGuardCode) => {
    const usedUtilities = new Set();
    // Check for specific utilities in the generated code using word boundaries
    const utilityChecks = [
        { pattern: /\bisType\b/, name: 'isType' },
        { pattern: /\bisString\b/, name: 'isString' },
        { pattern: /\bisNumber\b/, name: 'isNumber' },
        { pattern: /\bisBoolean\b/, name: 'isBoolean' },
        { pattern: /\bisDate\b/, name: 'isDate' },
        { pattern: /\bisArrayWithEachItem\b/, name: 'isArrayWithEachItem' },
        { pattern: /\bisObjectWithEachItem\b/, name: 'isObjectWithEachItem' },
        { pattern: /\bisUndefinedOr\b/, name: 'isUndefinedOr' },
        { pattern: /\bisNullOr\b/, name: 'isNullOr' },
        { pattern: /\bisNilOr\b/, name: 'isNilOr' },
        { pattern: /\bisOneOf\b/, name: 'isOneOf' },
        { pattern: /\bisOneOfTypes\b/, name: 'isOneOfTypes' },
        { pattern: /\bisEqualTo\b/, name: 'isEqualTo' },
        { pattern: /\bisAny\b/, name: 'isAny' },
        { pattern: /\bisUnknown\b/, name: 'isUnknown' },
        { pattern: /\bisDefined\b/, name: 'isDefined' },
        { pattern: /\bisNil\b/, name: 'isNil' },
        { pattern: /\bisEnum\b/, name: 'isEnum' },
        { pattern: /\bisNonEmptyString\b/, name: 'isNonEmptyString' },
        { pattern: /\bisNonNegativeNumber\b/, name: 'isNonNegativeNumber' },
        { pattern: /\bisPositiveNumber\b/, name: 'isPositiveNumber' },
        { pattern: /\bisNonPositiveNumber\b/, name: 'isNonPositiveNumber' },
        { pattern: /\bisNegativeNumber\b/, name: 'isNegativeNumber' },
        { pattern: /\bisInteger\b/, name: 'isInteger' },
        { pattern: /\bisPositiveInteger\b/, name: 'isPositiveInteger' },
        { pattern: /\bisNegativeInteger\b/, name: 'isNegativeInteger' },
        { pattern: /\bisNonNegativeInteger\b/, name: 'isNonNegativeInteger' },
        { pattern: /\bisNonPositiveInteger\b/, name: 'isNonPositiveInteger' },
        { pattern: /\bisBigInt\b/, name: 'isBigInt' },
        { pattern: /\bisNonEmptyArray\b/, name: 'isNonEmptyArray' },
        {
            pattern: /\bisNonEmptyArrayWithEachItem\b/,
            name: 'isNonEmptyArrayWithEachItem',
        },
        { pattern: /\bisPartialOf\b/, name: 'isPartialOf' },
        { pattern: /\bisNonNullObject\b/, name: 'isNonNullObject' },
        { pattern: /\bisTuple\b/, name: 'isTuple' },
        { pattern: /\bisIntersectionOf\b/, name: 'isIntersectionOf' },
        { pattern: /\bisExtensionOf\b/, name: 'isExtensionOf' },
        { pattern: /\bguardWithTolerance\b/, name: 'guardWithTolerance' },
        { pattern: /\bisAsserted\b/, name: 'isAsserted' },
        // New Web API guards from guardz 1.8.0
        { pattern: /\bisFileList\b/, name: 'isFileList' },
        { pattern: /\bisBlob\b/, name: 'isBlob' },
        { pattern: /\bisFormData\b/, name: 'isFormData' },
        { pattern: /\bisURL\b/, name: 'isURL' },
        { pattern: /\bisURLSearchParams\b/, name: 'isURLSearchParams' },
        { pattern: /\bisObjectWith\b/, name: 'isObjectWith' },
        { pattern: /\bisObject\b/, name: 'isObject' },
        { pattern: /\bisFunction\b/, name: 'isFunction' },
        { pattern: /\bisFile\b/, name: 'isFile' },
        { pattern: /\bisMap\b/, name: 'isMap' },
        { pattern: /\bisSet\b/, name: 'isSet' },
        { pattern: /\bisError\b/, name: 'isError' },
        { pattern: /\bgenerateTypeGuardError\b/, name: 'generateTypeGuardError' },
        // New type guards from guardz 1.11.6
        { pattern: /\bisNumberKey\b/, name: 'isNumberKey' },
        { pattern: /\bisNumeric\b/, name: 'isNumeric' },
        { pattern: /\bisIndexSignature\b/, name: 'isIndexSignature' },
        { pattern: /\bisSchema\b/, name: 'isSchema' },
        { pattern: /\bisBooleanLike\b/, name: 'isBooleanLike' },
        { pattern: /\bisDateLike\b/, name: 'isDateLike' },
        // New utility from guardz 1.11.6
        { pattern: /\bstringify\b/, name: 'stringify' },
        // New type guards from guardz 1.12.0
        { pattern: /\bisShape\b/, name: 'isShape' },
        { pattern: /\bisNestedType\b/, name: 'isNestedType' },
        { pattern: /\bisBranded\b/, name: 'isBranded' },
        { pattern: /\btoNumber\b/, name: 'toNumber' },
        { pattern: /\btoDate\b/, name: 'toDate' },
        { pattern: /\btoBoolean\b/, name: 'toBoolean' },
        // New type guards from guardz 1.12.1
        { pattern: /\bisSymbol\b/, name: 'isSymbol' },
    ];
    for (const check of utilityChecks) {
        if (check.pattern.test(typeGuardCode)) {
            usedUtilities.add(check.name);
        }
    }
    return Array.from(usedUtilities).sort();
};
exports.collectUsedGuardzUtilities = collectUsedGuardzUtilities;
// Collect used type guards in generated code
const collectUsedTypeGuards = (typeGuardCode) => {
    const usedTypeGuards = new Set();
    // Match type guard function calls (isXxx followed by parentheses, commas, closing braces, generic type parameters, or used as arguments)
    const typeGuardPattern = /\bis([A-Z][a-zA-Z0-9_]*)\b(?=\s*[<(),}])/g;
    let match;
    const guardzUtilities = [
        'isString',
        'isNumber',
        'isBoolean',
        'isDate',
        'isArrayWithEachItem',
        'isObjectWithEachItem',
        'isUndefinedOr',
        'isNullOr',
        'isNilOr',
        'isOneOf',
        'isOneOfTypes',
        'isEqualTo',
        'isAny',
        'isUnknown',
        'isDefined',
        'isNil',
        'isEnum',
        'isNonEmptyString',
        'isNonNegativeNumber',
        'isPositiveNumber',
        'isNonPositiveNumber',
        'isNegativeNumber',
        'isInteger',
        'isPositiveInteger',
        'isNegativeInteger',
        'isNonNegativeInteger',
        'isNonPositiveInteger',
        'isBigInt',
        'isNonEmptyArray',
        'isNonEmptyArrayWithEachItem',
        'isType',
        'isPartialOf',
        'isNonNullObject',
        'isTuple',
        'isIntersectionOf',
        'isExtensionOf',
        'guardWithTolerance',
        'isAsserted',
        // New Web API guards from guardz 1.8.0
        'isFileList',
        'isBlob',
        'isFormData',
        'isURL',
        'isURLSearchParams',
        // Additional utilities from guardz 1.10.3
        'isObjectWith',
        'isObject',
        'isFunction',
        'isFile',
        'isMap',
        'isSet',
        'isError',
        'generateTypeGuardError',
        // New type guards from guardz 1.11.6
        'isNumberKey',
        'isNumeric',
        'isIndexSignature',
        'isSchema',
        'isBooleanLike',
        'isDateLike',
        // New utility from guardz 1.11.6
        'stringify',
        // New type guards from guardz 1.12.0
        'isShape',
        'isNestedType',
        'isBranded',
        // New utilities from guardz 1.12.0
        'toNumber',
        'toDate',
        'toBoolean',
    ];
    while ((match = typeGuardPattern.exec(typeGuardCode)) !== null) {
        const typeGuardName = match[0];
        if (!guardzUtilities.includes(typeGuardName)) {
            usedTypeGuards.add(typeGuardName);
        }
    }
    return Array.from(usedTypeGuards).sort();
};
exports.collectUsedTypeGuards = collectUsedTypeGuards;
// Collect used guardz type aliases in generated code
const collectUsedGuardzTypeAliases = (typeGuardCode) => {
    // These are the guardz type aliases that should be imported if used
    const guardzTypeAliases = [
        'NonEmptyArray',
        'NonEmptyString',
        'NonNegativeNumber',
        'PositiveNumber',
        'NonPositiveNumber',
        'NegativeNumber',
        'Nullable',
        'Integer',
        'PositiveInteger',
        'NegativeInteger',
        'NonNegativeInteger',
        'NonPositiveInteger',
        'Numeric',
        'BooleanLike',
        'DateLike',
    ];
    const usedAliases = new Set();
    // Look for usages like NonEmptyArray<, NonEmptyString<, etc.
    for (const alias of guardzTypeAliases) {
        const pattern = new RegExp(`\\b${alias}\\b`, 'g');
        if (pattern.test(typeGuardCode)) {
            usedAliases.add(alias);
        }
    }
    return Array.from(usedAliases).sort();
};
exports.collectUsedGuardzTypeAliases = collectUsedGuardzTypeAliases;
// Check if TypeGuardFn import is needed (for non-recursive types)
const needsTypeGuardFn = (typeGuardCode) => {
    return typeGuardCode.includes('TypeGuardFn<');
};
exports.needsTypeGuardFn = needsTypeGuardFn;
// Check if TypeGuardFnConfig import is needed (for recursive types)
const needsTypeGuardFnConfig = (typeGuardCode) => {
    return typeGuardCode.includes('TypeGuardFnConfig');
};
exports.needsTypeGuardFnConfig = needsTypeGuardFnConfig;
// Check if a type is from the guardz library
const isGuardzType = (typeName) => {
    const guardzTypes = [
        'isString',
        'isNumber',
        'isBoolean',
        'isDate',
        'isArrayWithEachItem',
        'isObjectWithEachItem',
        'isUndefinedOr',
        'isNullOr',
        'isNilOr',
        'isOneOf',
        'isOneOfTypes',
        'isEqualTo',
        'isAny',
        'isUnknown',
        'isDefined',
        'isNil',
        'isEnum',
        'isNonEmptyString',
        'isNonNegativeNumber',
        'isPositiveNumber',
        'isNonPositiveNumber',
        'isNegativeNumber',
        'isInteger',
        'isPositiveInteger',
        'isNegativeInteger',
        'isNonNegativeInteger',
        'isNonPositiveInteger',
        'isBigInt',
        'isNonEmptyArray',
        'isNonEmptyArrayWithEachItem',
        'isType',
        'isPartialOf',
        'isNonNullObject',
        'isTuple',
        'isIntersectionOf',
        'isExtensionOf',
        'guardWithTolerance',
        'isAsserted',
        // New Web API guards from guardz 1.8.0
        'isFileList',
        'isBlob',
        'isFormData',
        'isURL',
        'isURLSearchParams',
        // Additional utilities from guardz 1.10.3
        'isObjectWith',
        'isObject',
        'isFunction',
        'isFile',
        'isMap',
        'isSet',
        'isError',
        'generateTypeGuardError',
        // Type aliases
        'NonEmptyArray',
        'NonEmptyString',
        'NonNegativeNumber',
        'PositiveNumber',
        'NonPositiveNumber',
        'NegativeNumber',
        'Nullable',
        'Integer',
        'PositiveInteger',
        'NegativeInteger',
        'NonNegativeInteger',
        'NonPositiveInteger',
        // New type guards from guardz 1.11.6
        'Numeric',
        'BooleanLike',
        'DateLike',
        'isNumeric',
        'isBooleanLike',
        'isDateLike',
        // New type guards from guardz 1.12.0
        'isShape',
        'isNestedType',
        'isBranded',
        // New type aliases from guardz 1.12.0
        'Branded',
        // New utilities from guardz 1.12.0
        'toNumber',
        'toDate',
        'toBoolean',
    ];
    return guardzTypes.includes(typeName);
};
exports.isGuardzType = isGuardzType;
// Collect types used in isAsserted<TypeName> in generated code
const collectAssertedTypesInCode = (typeGuardCode) => {
    const assertedTypes = new Set();
    const assertedPattern = /isAsserted<([A-Za-z0-9_$.]+)>/g;
    let match;
    while ((match = assertedPattern.exec(typeGuardCode)) !== null) {
        assertedTypes.add(match[1]);
    }
    return Array.from(assertedTypes);
};
exports.collectAssertedTypesInCode = collectAssertedTypesInCode;
//# sourceMappingURL=type-collectors.js.map