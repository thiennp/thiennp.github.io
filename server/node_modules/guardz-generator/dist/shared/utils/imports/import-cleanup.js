"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUnusedImports = void 0;
// Remove unused imports from generated files
const removeUnusedImports = (fileContent) => {
    // Parse the file content to extract imports and the rest of the code
    const lines = fileContent.split('\n');
    const importLines = [];
    const codeLines = [];
    let inImportSection = true;
    for (const line of lines) {
        if (inImportSection &&
            (line.trim().startsWith('import ') || line.trim() === '')) {
            importLines.push(line);
        }
        else {
            inImportSection = false;
            codeLines.push(line);
        }
    }
    // Extract all imports and their imported items
    const imports = [];
    for (const importLine of importLines) {
        const trimmed = importLine.trim();
        if (trimmed.startsWith('import ')) {
            // Check for namespace import: import type * as Namespace from 'module'
            const namespaceMatch = trimmed.match(/import\s+(?:type\s+)?\*\s+as\s+([A-Za-z_$][A-Za-z0-9_$]*)\s+from\s+['"]([^'"]+)['"]/);
            if (namespaceMatch) {
                imports.push({
                    line: importLine,
                    importedItems: [namespaceMatch[1]],
                    module: namespaceMatch[2],
                    isDefault: false,
                    isNamespace: true,
                });
                continue;
            }
            // Check for default import: import type DefaultType from 'module'
            const defaultMatch = trimmed.match(/import\s+(?:type\s+)?([A-Za-z_$][A-Za-z0-9_$]*)\s+from\s+['"]([^'"]+)['"]/);
            if (defaultMatch && !trimmed.includes('{')) {
                imports.push({
                    line: importLine,
                    importedItems: [defaultMatch[1]],
                    module: defaultMatch[2],
                    isDefault: true,
                    isNamespace: false,
                });
            }
            else {
                // Check for named import: import type { Type1, Type2 } from 'module'
                const match = trimmed.match(/import\s+(?:type\s+)?\{?\s*([^}]+?)\s*\}?\s+from\s+['"]([^'"]+)['"]/);
                if (match) {
                    const importedItems = match[1].split(',').map(item => item.trim());
                    imports.push({
                        line: importLine,
                        importedItems,
                        module: match[2],
                        isDefault: false,
                        isNamespace: false,
                    });
                }
            }
        }
    }
    // Combine all code lines to analyze usage
    const codeContent = codeLines.join('\n');
    // Check which imported items are actually used
    const usedImports = [];
    for (const importInfo of imports) {
        for (const item of importInfo.importedItems) {
            // Check if the item is used in the code
            let isUsed = false;
            if (importInfo.isNamespace) {
                // For namespace imports, check for namespace.ClassName pattern
                isUsed = new RegExp(`\\b${item}\\.[a-zA-Z_][a-zA-Z0-9_]*\\b`).test(codeContent);
            }
            else {
                // For regular imports, check for direct usage
                isUsed = new RegExp(`\\b${item}\\b`).test(codeContent);
            }
            if (isUsed) {
                usedImports.push(item);
            }
        }
    }
    // Rebuild import statements with only used items
    const newImportLines = [];
    for (const importInfo of imports) {
        const usedItems = importInfo.importedItems.filter(item => usedImports.includes(item));
        if (usedItems.length > 0) {
            // Determine if it's a type import
            const isTypeImport = importInfo.line.includes('import type');
            const importKeyword = isTypeImport ? 'import type' : 'import';
            if (importInfo.isNamespace) {
                // Namespace import: import type * as Namespace from 'module'
                newImportLines.push(`${importKeyword} * as ${usedItems[0]} from '${importInfo.module}';`);
            }
            else if (importInfo.isDefault && usedItems.length === 1) {
                // Default import: import type DefaultType from 'module'
                newImportLines.push(`${importKeyword} ${usedItems[0]} from '${importInfo.module}';`);
            }
            else {
                // Named import: import type { Type1, Type2 } from 'module'
                if (usedItems.length === 1) {
                    newImportLines.push(`${importKeyword} { ${usedItems[0]} } from '${importInfo.module}';`);
                }
                else {
                    newImportLines.push(`${importKeyword} { ${usedItems.join(', ')} } from '${importInfo.module}';`);
                }
            }
        }
    }
    // Combine the cleaned imports with the code
    return [...newImportLines, '', ...codeLines].join('\n');
};
exports.removeUnusedImports = removeUnusedImports;
//# sourceMappingURL=import-cleanup.js.map