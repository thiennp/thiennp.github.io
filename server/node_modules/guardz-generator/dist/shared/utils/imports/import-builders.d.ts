import * as ts from 'typescript';
import type { ImportItem, ImportStrategyContext } from './import-strategy';
import type { ImportInfo } from '../../../domain/types';
/**
 * Shared context that can be reused across multiple file generations
 * This contains data that doesn't change between files in the same generation run
 */
export interface SharedImportContext {
    sourceFiles: ts.SourceFile[];
    outputDir: string;
    importMap?: Map<string, ImportInfo>;
}
/**
 * Clears the import strategy cache
 * Should be called at the start of each generation run
 */
export declare const clearImportStrategyCache: () => void;
/**
 * Builds import information for a type guard function, determining the correct import path
 *
 * @param name - The name of the type guard function (e.g., 'isUser', 'isProduct')
 * @param context - The import strategy context containing source files and configuration
 * @returns ImportItem with import details or null if the type guard should not be imported
 *
 * @example
 * ```typescript
 * const context = {
 *   sourceFiles: [], // array of source files
 *   outputDir: '/path/to/output',
 *   currentSourceFile: ts.createSourceFile('src/components/App.ts', '', ts.ScriptTarget.Latest)
 * };
 *
 * // For a local type guard
 * const localGuard = buildTypeGuardImportInfo('isUser', context);
 * // Returns: { name: 'isUser', path: './isUser.guardz', isType: false, isDefault: false }
 *
 * // For a type guard from a different directory
 * const nestedGuard = buildTypeGuardImportInfo('isProduct', context);
 * // Returns: { name: 'isProduct', path: './types/isProduct.guardz', isType: false, isDefault: false }
 *
 * // For a non-existent type guard
 * const missingGuard = buildTypeGuardImportInfo('isNonExistent', context);
 * // Returns: null
 * ```
 */
export declare const buildTypeGuardImportInfo: (name: string, context: ImportStrategyContext) => ImportItem | null;
/**
 * Builds complete import statements for a type guard file, including types, utilities, and type guards
 *
 * @param importTypes - Array of type names that need to be imported (e.g., ['User', 'Product'])
 * @param usedEnums - Array of enum names that need to be imported (e.g., ['UserRole', 'ProductStatus'])
 * @param usedGuardzUtilities - Array of guardz utility function names (e.g., ['isString', 'isNumber'])
 * @param usedTypeGuards - Array of local type guard function names (e.g., ['isUser', 'isProduct'])
 * @param usedGuardzTypeAliases - Array of guardz type alias names (e.g., ['TypeGuardFn', 'GuardResult'])
 * @param needsTypeGuardFnImport - Whether to import the TypeGuardFn type from guardz
 * @param outputDir - The output directory where the type guard file will be generated
 * @param sourceFiles - Array of all TypeScript source files in the project
 * @param importMap - Optional map of type names to their import information
 * @param currentSourceFile - Optional current source file for relative path resolution
 * @param typeGuardCode - Optional type guard code to analyze for additional imports
 * @returns Formatted string containing all necessary import statements
 *
 * @example
 * ```typescript
 * const importTypes = ['User', 'Product'];
 * const usedEnums = ['UserRole'];
 * const usedGuardzUtilities = ['isString', 'isNumber', 'isType'];
 * const usedTypeGuards = ['isUser', 'isProduct'];
 * const usedGuardzTypeAliases = ['TypeGuardFn'];
 *
 * const importStatements = buildImportStatements(
 *   importTypes,
 *   usedEnums,
 *   usedGuardzUtilities,
 *   usedTypeGuards,
 *   usedGuardzTypeAliases,
 *   true,
 *   '/path/to/output',
 *   sourceFiles,
 *   importMap,
 *   currentSourceFile,
 *   'single'
 * );
 *
 * // Returns a string like:
 * // "import type { User } from './types/User';
 * //  import type { Product } from './types/Product';
 * //  import type { UserRole } from './enums/UserRole';
 * //  import { isString, isNumber, isType, TypeGuardFn } from 'guardz';
 * //  import { isUser } from './isUser.guardz';
 * //  import { isProduct } from './isProduct.guardz';"
 * ```
 */
export declare const buildImportStatements: (importTypes: string[], usedEnums: string[], usedGuardzUtilities: string[], usedTypeGuards: string[], usedGuardzTypeAliases: string[], needsTypeGuardFnImport: boolean, outputDir: string, sourceFiles: ts.SourceFile[], importMap?: Map<string, ImportInfo>, currentSourceFile?: ts.SourceFile, typeGuardCode?: string) => string;
/**
 * Optimized version of buildImportStatements that uses shared context
 * This version is more efficient for batch processing multiple files
 *
 * @param importTypes - Array of type names that need to be imported
 * @param usedEnums - Array of enum names that need to be imported
 * @param usedGuardzUtilities - Array of guardz utility function names
 * @param usedTypeGuards - Array of local type guard function names
 * @param usedGuardzTypeAliases - Array of guardz type alias names
 * @param needsTypeGuardFnImport - Whether to import the TypeGuardFn type from guardz
 * @param sharedContext - Shared context containing reusable data
 * @param currentSourceFile - Optional current source file for relative path resolution
 * @param typeGuardCode - Optional type guard code to analyze for additional imports
 * @returns Formatted string containing all necessary import statements
 */
export declare const buildImportStatementsOptimized: (importTypes: string[], usedEnums: string[], usedGuardzUtilities: string[], usedTypeGuards: string[], usedGuardzTypeAliases: string[], needsTypeGuardFnImport: boolean, sharedContext: SharedImportContext, currentSourceFile?: ts.SourceFile, typeGuardCode?: string) => string;
//# sourceMappingURL=import-builders.d.ts.map