"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefaultExport = exports.findNamespaceImport = exports.extractNamespaceFromQualifiedType = exports.buildImportMap = exports.extractImportsFromSourceFile = exports.extractImportsFromFile = exports.ImportTypeEnum = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const ts = __importStar(require("typescript"));
const logging_1 = require("../logging");
const guard_finders_1 = require("../types/guard-finders");
// ============================================================================
// TYPES AND ENUMS
// ============================================================================
/**
 * Enum representing different types of imports based on their source and type guard availability
 */
var ImportTypeEnum;
(function (ImportTypeEnum) {
    /** Type defined in the same file (no import needed) */
    ImportTypeEnum["FROM_SAME_FILE"] = "FROM_SAME_FILE";
    /** Type from node_modules with type guard also from node_modules */
    ImportTypeEnum["FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES"] = "FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES";
    /** Type from node_modules with type guard from project (matched by import path and type name) */
    ImportTypeEnum["FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL"] = "FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL";
    /** Type from node_modules without any type guard */
    ImportTypeEnum["FROM_NODE_MODULES_WITHOUT_TYPE_GUARD"] = "FROM_NODE_MODULES_WITHOUT_TYPE_GUARD";
    /** Type from global path (tsconfig path mappings) */
    ImportTypeEnum["FROM_GLOBAL_PATH"] = "FROM_GLOBAL_PATH";
    /** Type from relative path (local project files) */
    ImportTypeEnum["FROM_RELATIVE_PATH"] = "FROM_RELATIVE_PATH";
    /** Native types that are not imported and not part of supported guardz types */
    ImportTypeEnum["FROM_NATIVE"] = "FROM_NATIVE";
})(ImportTypeEnum || (exports.ImportTypeEnum = ImportTypeEnum = {}));
// ============================================================================
// TSConfig PATH RESOLUTION
// ============================================================================
/**
 * Reads and parses tsconfig.json path mappings
 *
 * @param projectRoot - The root directory of the project containing tsconfig.json
 * @returns A Map where keys are path patterns and values are arrays of mapped paths
 *
 * @example
 * ```typescript
 * // For tsconfig.json with:
 * // {
 * //   "compilerOptions": {
 * //     "paths": {
 * //       "@/*": ["src/*"],
 * //       "@/components/*": ["src/components/*"]
 * //     }
 * //   }
 * // }
 *
 * const mappings = getTsConfigPathMappings('/path/to/project');
 * // Returns: Map {
 * //   "@/*" => ["src/*"],
 * //   "@/components/*" => ["src/components/*"]
 * // }
 * ```
 */
const getTsConfigPathMappings = (projectRoot) => {
    (0, logging_1.log)(`[getTsConfigPathMappings] Input: projectRoot = "${projectRoot}"`);
    const pathMappings = new Map();
    try {
        const tsconfigPath = path.join(projectRoot, 'tsconfig.json');
        (0, logging_1.log)(`[getTsConfigPathMappings] Looking for tsconfig at: "${tsconfigPath}"`);
        if (fs.existsSync(tsconfigPath)) {
            (0, logging_1.log)(`[getTsConfigPathMappings] tsconfig.json found, parsing...`);
            const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));
            if (tsconfig.compilerOptions?.paths) {
                (0, logging_1.log)(`[getTsConfigPathMappings] Found paths in tsconfig:`, tsconfig.compilerOptions.paths);
                for (const [pattern, paths] of Object.entries(tsconfig.compilerOptions.paths)) {
                    if (Array.isArray(paths)) {
                        pathMappings.set(pattern, paths);
                        (0, logging_1.log)(`[getTsConfigPathMappings] Added mapping: "${pattern}" => [${paths.join(', ')}]`);
                    }
                }
            }
            else {
                (0, logging_1.log)(`[getTsConfigPathMappings] No paths found in tsconfig.compilerOptions`);
            }
        }
        else {
            (0, logging_1.log)(`[getTsConfigPathMappings] tsconfig.json not found at: "${tsconfigPath}"`);
        }
    }
    catch (error) {
        (0, logging_1.log)(`[getTsConfigPathMappings] Error parsing tsconfig:`, error);
        // Ignore tsconfig parsing errors
    }
    (0, logging_1.log)(`[getTsConfigPathMappings] Output: ${pathMappings.size} mappings found`);
    return pathMappings;
};
/**
 * Finds the project root by looking for tsconfig.json in parent directories
 *
 * @param currentSourceFile - The TypeScript source file to start the search from
 * @returns The absolute path to the project root directory
 *
 * @example
 * ```typescript
 * const sourceFile = ts.createSourceFile('src/components/Button.ts', '', ts.ScriptTarget.Latest);
 * const projectRoot = findProjectRoot(sourceFile);
 * // Returns: '/path/to/project' (where tsconfig.json is located)
 * ```
 */
const findProjectRoot = (currentSourceFile) => {
    (0, logging_1.log)(`[findProjectRoot] Input: currentSourceFile.fileName = "${currentSourceFile.fileName}"`);
    let projectRoot = path.dirname(currentSourceFile.fileName);
    (0, logging_1.log)(`[findProjectRoot] Starting search from: "${projectRoot}"`);
    while (projectRoot !== path.dirname(projectRoot)) {
        const tsconfigPath = path.join(projectRoot, 'tsconfig.json');
        (0, logging_1.log)(`[findProjectRoot] Checking for tsconfig at: "${tsconfigPath}"`);
        if (fs.existsSync(tsconfigPath)) {
            (0, logging_1.log)(`[findProjectRoot] Found tsconfig.json at: "${projectRoot}"`);
            break;
        }
        projectRoot = path.dirname(projectRoot);
    }
    (0, logging_1.log)(`[findProjectRoot] Output: projectRoot = "${projectRoot}"`);
    return projectRoot;
};
/**
 * Resolves global path using tsconfig mappings
 *
 * @param importPath - The import path to resolve (e.g., '@/components/Button')
 * @param currentSourceFile - The TypeScript source file making the import
 * @returns The resolved path or null if no mapping is found
 *
 * @example
 * ```typescript
 * // With tsconfig.json paths: { "@/*": ["src/*"] }
 *
 * const sourceFile = ts.createSourceFile('src/pages/Home.ts', '', ts.ScriptTarget.Latest);
 *
 * const resolved = resolveGlobalPath('@/components/Button', sourceFile);
 * // Returns: 'src/components/Button'
 *
 * const notFound = resolveGlobalPath('unknown/path', sourceFile);
 * // Returns: null
 * ```
 */
const resolveGlobalPath = (importPath, currentSourceFile) => {
    (0, logging_1.log)(`[resolveGlobalPath] Input: importPath = "${importPath}", currentSourceFile.fileName = "${currentSourceFile.fileName}"`);
    const projectRoot = findProjectRoot(currentSourceFile);
    const pathMappings = getTsConfigPathMappings(projectRoot);
    (0, logging_1.log)(`[resolveGlobalPath] Checking ${pathMappings.size} path mappings for import: "${importPath}"`);
    // Check if the import path matches any tsconfig path mapping
    for (const [pattern, paths] of pathMappings) {
        // Convert pattern to regex (simple wildcard matching)
        const regexPattern = pattern
            .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
            .replace(/\\\*/g, '.*'); // Replace escaped * with .*
        const regex = new RegExp(`^${regexPattern}$`);
        (0, logging_1.log)(`[resolveGlobalPath] Testing pattern: "${pattern}" (regex: ${regexPattern}) against import: "${importPath}"`);
        if (regex.test(importPath)) {
            const mappedPath = paths[0];
            if (mappedPath) {
                // Replace the pattern with the mapped path
                const result = importPath.replace(pattern.replace('*', ''), mappedPath.replace('*', ''));
                (0, logging_1.log)(`[resolveGlobalPath] Match found! "${importPath}" => "${result}"`);
                return result;
            }
        }
    }
    (0, logging_1.log)(`[resolveGlobalPath] No mapping found for: "${importPath}"`);
    return null;
};
/**
 * Checks if an import is from node_modules
 *
 * @param importPath - The import path to check (e.g., 'lodash', 'react', 'axios')
 * @param currentSourceFile - The TypeScript source file making the import
 * @returns true if the import resolves to a node_modules package, false otherwise
 *
 * @example
 * ```typescript
 * const sourceFile = ts.createSourceFile('src/components/Button.ts', '', ts.ScriptTarget.Latest);
 *
 * const isNodeModule = isFromNodeModules('lodash', sourceFile);
 * // Returns: true (if lodash is installed in node_modules)
 *
 * const isLocal = isFromNodeModules('./Button', sourceFile);
 * // Returns: false (relative import)
 *
 * const isGlobal = isFromNodeModules('@/components/Button', sourceFile);
 * // Returns: false (tsconfig path alias)
 * ```
 */
const isFromNodeModules = (importPath, currentSourceFile) => {
    (0, logging_1.log)(`[isFromNodeModules] Input: importPath = "${importPath}", currentSourceFile.fileName = "${currentSourceFile.fileName}"`);
    if (importPath.startsWith('.') || importPath.startsWith('/')) {
        (0, logging_1.log)(`[isFromNodeModules] Early return: relative/absolute path detected`);
        return false;
    }
    try {
        const currentDir = path.dirname(currentSourceFile.fileName);
        (0, logging_1.log)(`[isFromNodeModules] Resolving from currentDir: "${currentDir}"`);
        const resolvedPath = require.resolve(importPath, { paths: [currentDir] });
        (0, logging_1.log)(`[isFromNodeModules] Resolved path: "${resolvedPath}"`);
        const isNodeModule = resolvedPath.includes('node_modules');
        (0, logging_1.log)(`[isFromNodeModules] Output: ${isNodeModule} (contains 'node_modules': ${resolvedPath.includes('node_modules')})`);
        return isNodeModule;
    }
    catch (error) {
        (0, logging_1.log)(`[isFromNodeModules] Error resolving path:`, error);
        (0, logging_1.log)(`[isFromNodeModules] Output: false (resolution failed)`);
        return false;
    }
};
// ============================================================================
// TYPE GUARD DETECTION
// ============================================================================
/**
 * Checks if a type guard exists in node_modules
 *
 * @param typeName - The name of the type to check (e.g., 'User', 'Product')
 * @param importPath - The import path of the type (e.g., 'my-package')
 * @param currentSourceFile - The TypeScript source file making the import
 * @returns true if a type guard file exists in the node_modules package, false otherwise
 *
 * @example
 * ```typescript
 * const sourceFile = ts.createSourceFile('src/components/Button.ts', '', ts.ScriptTarget.Latest);
 *
 * // Checks if 'my-package/node_modules/isUser.guardz.js' exists
 * const hasGuard = hasTypeGuardInNodeModules('User', 'my-package', sourceFile);
 * // Returns: true (if the guard file exists in the package)
 *
 * const noGuard = hasTypeGuardInNodeModules('Product', 'lodash', sourceFile);
 * // Returns: false (lodash doesn't have type guards)
 * ```
 */
const hasTypeGuardInNodeModules = (typeName, importPath, currentSourceFile) => {
    (0, logging_1.log)(`[hasTypeGuardInNodeModules] Input: typeName = "${typeName}", importPath = "${importPath}", currentSourceFile.fileName = "${currentSourceFile.fileName}"`);
    try {
        const currentDir = path.dirname(currentSourceFile.fileName);
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Resolving from currentDir: "${currentDir}"`);
        const resolvedPath = require.resolve(importPath, { paths: [currentDir] });
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Resolved path: "${resolvedPath}"`);
        const guardFile = path.join(path.dirname(resolvedPath), `is${typeName}.guardz.js`);
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Looking for guard file: "${guardFile}"`);
        const exists = fs.existsSync(guardFile);
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Output: ${exists} (file exists: ${exists})`);
        return exists;
    }
    catch (error) {
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Error resolving path:`, error);
        (0, logging_1.log)(`[hasTypeGuardInNodeModules] Output: false (resolution failed)`);
        return false;
    }
};
/**
 * Checks if a type guard exists in project (matched by import path and type name)
 *
 * @param typeName - The name of the type to check (e.g., 'User', 'Product')
 * @param importPath - The import path of the type (e.g., 'my-package', './types/User')
 * @param sourceFiles - Array of all TypeScript source files in the project
 * @param projectRoot - The root directory of the project
 * @returns true if a type guard exists and imports the type from the same path, false otherwise
 *
 * @example
 * ```typescript
 * const sourceFiles = []; // array of source files
 * const projectRoot = '/path/to/project';
 *
 * // Checks if there's a type guard that imports User from 'my-package'
 * const hasGuard = hasTypeGuardInProject('User', 'my-package', sourceFiles, projectRoot);
 * // Returns: true (if isUser.guardz.ts exists and imports User from 'my-package')
 *
 * // Checks if there's a type guard that imports Product from './types/Product'
 * const hasLocalGuard = hasTypeGuardInProject('Product', './types/Product', sourceFiles, projectRoot);
 * // Returns: true (if isProduct.guardz.ts exists and imports Product from './types/Product')
 *
 * // Different import path - won't match
 * const noMatch = hasTypeGuardInProject('User', 'different-package', sourceFiles, projectRoot);
 * // Returns: false (even if isUser.guardz.ts exists, it imports from different path)
 * ```
 */
const hasTypeGuardInProject = (typeName, importPath, sourceFiles, projectRoot) => {
    (0, logging_1.log)(`[hasTypeGuardInProject] Input: typeName = "${typeName}", importPath = "${importPath}", sourceFiles.length = ${sourceFiles.length}, projectRoot = "${projectRoot}"`);
    const found = (0, guard_finders_1.findTypeGuardInProject)(typeName, sourceFiles, projectRoot);
    if (!found) {
        (0, logging_1.log)(`[hasTypeGuardInProject] No type guard found for type: "${typeName}"`);
        (0, logging_1.log)(`[hasTypeGuardInProject] Output: false (no guard file found)`);
        return false;
    }
    (0, logging_1.log)(`[hasTypeGuardInProject] Found guard file: "${found.filePath}"`);
    // Read the guard file to check if it imports the type from the same importPath
    try {
        const guardContent = fs.readFileSync(found.filePath, 'utf8');
        (0, logging_1.log)(`[hasTypeGuardInProject] Guard file content length: ${guardContent.length} characters`);
        // Check if the guard file imports the type from the same importPath
        const importPatterns = [
            // Named import: import { TypeName } from 'importPath'
            new RegExp(`import\\s*{\\s*[^}]*\\b${typeName}\\b[^}]*\\s*}\\s*from\\s*['"]${importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`, 'g'),
            // Default import: import TypeName from 'importPath'
            new RegExp(`import\\s+${typeName}\\s+from\\s*['"]${importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`, 'g'),
            // Type import: import type { TypeName } from 'importPath'
            new RegExp(`import\\s+type\\s*{\\s*[^}]*\\b${typeName}\\b[^}]*\\s*}\\s*from\\s*['"]${importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`, 'g'),
            // Type default import: import type TypeName from 'importPath'
            new RegExp(`import\\s+type\\s+${typeName}\\s+from\\s*['"]${importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`, 'g'),
        ];
        (0, logging_1.log)(`[hasTypeGuardInProject] Testing ${importPatterns.length} import patterns against guard file content`);
        // Check if any of the import patterns match
        for (let i = 0; i < importPatterns.length; i++) {
            const pattern = importPatterns[i];
            const patternType = [
                'Named import',
                'Default import',
                'Type import',
                'Type default import',
            ][i];
            (0, logging_1.log)(`[hasTypeGuardInProject] Testing pattern ${i + 1} (${patternType}): ${pattern.source}`);
            if (pattern.test(guardContent)) {
                (0, logging_1.log)(`[hasTypeGuardInProject] Pattern ${i + 1} matched!`);
                (0, logging_1.log)(`[hasTypeGuardInProject] Output: true (import path matches)`);
                return true;
            }
        }
        (0, logging_1.log)(`[hasTypeGuardInProject] No import patterns matched`);
        (0, logging_1.log)(`[hasTypeGuardInProject] Output: false (import path doesn't match)`);
        return false;
    }
    catch (error) {
        (0, logging_1.log)(`[hasTypeGuardInProject] Error reading guard file:`, error);
        (0, logging_1.log)(`[hasTypeGuardInProject] Output: false (file read error)`);
        // If we can't read the file, assume it doesn't match
        return false;
    }
};
// ============================================================================
// SAME FILE TYPE DETECTION
// ============================================================================
/**
 * Checks if a type is defined in the current source file
 *
 * @param typeName - The name of the type to check (e.g., 'User', 'Product')
 * @param sourceFile - The TypeScript source file to search in
 * @returns true if the type is defined in the current file, false otherwise
 *
 * @example
 * ```typescript
 * const sourceCode = `
 * export interface User {
 *   id: number;
 *   name: string;
 * }
 *
 * export type Product = {
 *   id: number;
 *   title: string;
 * };
 * `;
 *
 * const sourceFile = ts.createSourceFile('src/types.ts', sourceCode, ts.ScriptTarget.Latest);
 *
 * const hasUser = isDefinedInCurrentFile('User', sourceFile);
 * // Returns: true (interface User is defined)
 *
 * const hasProduct = isDefinedInCurrentFile('Product', sourceFile);
 * // Returns: true (type Product is defined)
 *
 * const hasNotFound = isDefinedInCurrentFile('NotFound', sourceFile);
 * // Returns: false (type NotFound is not defined)
 * ```
 */
const isDefinedInCurrentFile = (typeName, sourceFile) => {
    (0, logging_1.log)(`[isDefinedInCurrentFile] Input: typeName = "${typeName}", sourceFile.fileName = "${sourceFile.fileName}"`);
    let found = false;
    const visitNode = (node) => {
        // Check for interface declarations
        if (ts.isInterfaceDeclaration(node) && node.name.text === typeName) {
            (0, logging_1.log)(`[isDefinedInCurrentFile] ✓ Found interface declaration: "${typeName}"`);
            found = true;
            return;
        }
        // Check for type alias declarations
        if (ts.isTypeAliasDeclaration(node) && node.name.text === typeName) {
            (0, logging_1.log)(`[isDefinedInCurrentFile] ✓ Found type alias declaration: "${typeName}"`);
            found = true;
            return;
        }
        // Check for class declarations
        if (ts.isClassDeclaration(node) && node.name?.text === typeName) {
            (0, logging_1.log)(`[isDefinedInCurrentFile] ✓ Found class declaration: "${typeName}"`);
            found = true;
            return;
        }
        // Check for enum declarations
        if (ts.isEnumDeclaration(node) && node.name.text === typeName) {
            (0, logging_1.log)(`[isDefinedInCurrentFile] ✓ Found enum declaration: "${typeName}"`);
            found = true;
            return;
        }
        // Continue visiting children if not found yet
        if (!found) {
            ts.forEachChild(node, visitNode);
        }
    };
    visitNode(sourceFile);
    (0, logging_1.log)(`[isDefinedInCurrentFile] Output: ${found} (type "${typeName}" ${found ? 'found' : 'not found'} in current file)`);
    return found;
};
// ============================================================================
// IMPORT TYPE DETERMINATION
// ============================================================================
/**
 * Determines the import type based on the specified order and logic
 *
 * @param typeName - The name of the type being imported (e.g., 'User', 'Product')
 * @param importPath - The import path (e.g., 'lodash', '@/components/Button', './types/User')
 * @param sourceFile - The TypeScript source file making the import
 * @param sourceFiles - Array of all TypeScript source files in the project
 * @param projectRoot - The root directory of the project
 * @returns ImportTypeEnum indicating the type of import based on the detection logic
 *
 * @example
 * ```typescript
 * const sourceFile = ts.createSourceFile('src/components/Button.ts', '', ts.ScriptTarget.Latest);
 * const sourceFiles = []; // array of source files
 * const projectRoot = '/path/to/project';
 *
 * // Node module with type guard in node_modules
 * const type1 = determineImportType('User', 'my-package', sourceFile, sourceFiles, projectRoot);
 * // Returns: ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES
 *
 * // Node module with type guard in project
 * const type2 = determineImportType('Product', 'lodash', sourceFile, sourceFiles, projectRoot);
 * // Returns: ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL
 *
 * // Node module without type guard
 * const type3 = determineImportType('Config', 'axios', sourceFile, sourceFiles, projectRoot);
 * // Returns: ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD
 *
 * // Global path (tsconfig alias)
 * const type4 = determineImportType('Button', '@/components/Button', sourceFile, sourceFiles, projectRoot);
 * // Returns: ImportTypeEnum.FROM_GLOBAL_PATH
 *
 * // Relative path
 * const type5 = determineImportType('User', './types/User', sourceFile, sourceFiles, projectRoot);
 * // Returns: ImportTypeEnum.FROM_RELATIVE_PATH
 * ```
 */
const determineImportType = (typeName, importPath, sourceFile, sourceFiles, projectRoot) => {
    (0, logging_1.log)(`[determineImportType] Input: typeName = "${typeName}", importPath = "${importPath}", sourceFile.fileName = "${sourceFile.fileName}", sourceFiles.length = ${sourceFiles.length}, projectRoot = "${projectRoot}"`);
    // 1. Check if type is defined in the same file (highest priority)
    (0, logging_1.log)(`[determineImportType] Step 1: Checking if defined in same file`);
    if (isDefinedInCurrentFile(typeName, sourceFile)) {
        (0, logging_1.log)(`[determineImportType] ✓ Type is defined in same file`);
        (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_SAME_FILE}`);
        return ImportTypeEnum.FROM_SAME_FILE;
    }
    else {
        (0, logging_1.log)(`[determineImportType] ✗ Type is not defined in same file`);
    }
    // 2. Check if type is a native type (second priority)
    (0, logging_1.log)(`[determineImportType] Step 2: Checking if native type`);
    if (isNativeSupportedType(typeName)) {
        (0, logging_1.log)(`[determineImportType] ✓ Type is native type`);
        (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_NATIVE}`);
        return ImportTypeEnum.FROM_NATIVE;
    }
    else {
        (0, logging_1.log)(`[determineImportType] ✗ Type is not native type`);
    }
    // 3. From node_modules, with typeguard from node_modules
    (0, logging_1.log)(`[determineImportType] Step 3: Checking if from node_modules`);
    if (isFromNodeModules(importPath, sourceFile)) {
        (0, logging_1.log)(`[determineImportType] ✓ From node_modules, checking for type guards`);
        (0, logging_1.log)(`[determineImportType] Step 1a: Checking for type guard in node_modules`);
        if (hasTypeGuardInNodeModules(typeName, importPath, sourceFile)) {
            (0, logging_1.log)(`[determineImportType] ✓ Type guard found in node_modules`);
            (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES}`);
            return ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES;
        }
        else {
            (0, logging_1.log)(`[determineImportType] ✗ No type guard in node_modules`);
            (0, logging_1.log)(`[determineImportType] Step 1b: Checking for type guard in project`);
            if (hasTypeGuardInProject(typeName, importPath, sourceFiles, projectRoot)) {
                // 2. From node_modules, with typeguard from project (match by importPath and typeName)
                (0, logging_1.log)(`[determineImportType] ✓ Type guard found in project`);
                (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL}`);
                return ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL;
            }
            else {
                // 3. From node_modules, without typeguard
                (0, logging_1.log)(`[determineImportType] ✗ No type guard in project`);
                (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD}`);
                return ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD;
            }
        }
    }
    else {
        (0, logging_1.log)(`[determineImportType] ✗ Not from node_modules`);
        // 4. From global path (tsconfig)
        (0, logging_1.log)(`[determineImportType] Step 4: Checking if from global path (tsconfig)`);
        const globalPath = resolveGlobalPath(importPath, sourceFile);
        if (globalPath) {
            (0, logging_1.log)(`[determineImportType] ✓ Global path resolved: "${globalPath}"`);
            (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_GLOBAL_PATH}`);
            return ImportTypeEnum.FROM_GLOBAL_PATH;
        }
        else {
            // 5. Fallback: relative path
            (0, logging_1.log)(`[determineImportType] ✗ Not a global path, assuming relative path`);
            (0, logging_1.log)(`[determineImportType] Output: ${ImportTypeEnum.FROM_RELATIVE_PATH}`);
            return ImportTypeEnum.FROM_RELATIVE_PATH;
        }
    }
};
// ============================================================================
// IMPORT EXTRACTION
// ============================================================================
/**
 * Extracts all import statements from a source file
 *
 * @param sourceFile - The TypeScript source file to extract imports from
 * @param sourceFiles - Optional array of all source files in the project for context
 * @returns Array of ImportInfo objects containing details about each import
 *
 * @example
 * ```typescript
 * const sourceCode = `
 * import { User, Product } from 'my-package';
 * import Button from '@/components/Button';
 * import type { Config } from './types/Config';
 * `;
 *
 * const sourceFile = ts.createSourceFile('src/components/App.ts', sourceCode, ts.ScriptTarget.Latest);
 * const sourceFiles = []; // array of all source files
 *
 * const imports = extractImportsFromFile(sourceFile, sourceFiles);
 * // Returns: [
 * //   {
 * //     typeName: 'User',
 * //     importPath: 'my-package',
 * //     isDefault: false,
 * //     importType: ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD
 * //   },
 * //   {
 * //     typeName: 'Product',
 * //     importPath: 'my-package',
 * //     isDefault: false,
 * //     importType: ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD
 * //   },
 * //   {
 * //     typeName: 'Button',
 * //     importPath: '@/components/Button',
 * //     isDefault: true,
 * //     importType: ImportTypeEnum.FROM_GLOBAL_PATH
 * //   },
 * //   {
 * //     typeName: 'Config',
 * //     importPath: './types/Config',
 * //     isDefault: false,
 * //     importType: ImportTypeEnum.FROM_RELATIVE_PATH
 * //   }
 * // ]
 * ```
 */
const extractImportsFromFile = (sourceFile, sourceFiles = []) => {
    (0, logging_1.log)(`[extractImportsFromFile] Input: sourceFile.fileName = "${sourceFile.fileName}", sourceFiles.length = ${sourceFiles.length}`);
    const imports = [];
    const projectRoot = process.cwd();
    (0, logging_1.log)(`[extractImportsFromFile] Using projectRoot: "${projectRoot}"`);
    let importCount = 0;
    ts.forEachChild(sourceFile, (node) => {
        if (ts.isImportDeclaration(node)) {
            importCount++;
            const importPath = node.moduleSpecifier.text;
            (0, logging_1.log)(`[extractImportsFromFile] Processing import ${importCount}: "${importPath}"`);
            const typeNames = [];
            // Extract type names from the import
            if (node.importClause) {
                if (node.importClause.name) {
                    typeNames.push(node.importClause.name.text);
                    (0, logging_1.log)(`[extractImportsFromFile] Found default import: "${node.importClause.name.text}"`);
                }
                if (node.importClause.namedBindings &&
                    ts.isNamedImports(node.importClause.namedBindings)) {
                    node.importClause.namedBindings.elements.forEach(element => {
                        typeNames.push(element.name.text);
                        (0, logging_1.log)(`[extractImportsFromFile] Found named import: "${element.name.text}"`);
                    });
                }
                // Handle namespace imports: import * as ts from 'typescript'
                if (node.importClause.namedBindings &&
                    ts.isNamespaceImport(node.importClause.namedBindings)) {
                    const namespaceName = node.importClause.namedBindings.name.text;
                    (0, logging_1.log)(`[extractImportsFromFile] Found namespace import: "${namespaceName}" from "${importPath}"`);
                    // Store namespace import information for later use
                    const namespaceImportInfo = {
                        typeName: namespaceName,
                        importPath: { [sourceFile.fileName]: importPath },
                        isDefault: false,
                        importType: determineImportType(namespaceName, importPath, sourceFile, sourceFiles, projectRoot),
                        isNamespace: true,
                        namespaceName,
                    };
                    imports.push(namespaceImportInfo);
                }
            }
            (0, logging_1.log)(`[extractImportsFromFile] Extracted ${typeNames.length} type names: [${typeNames.join(', ')}]`);
            // For each typeName, determine importType and create ImportInfo
            for (const typeName of typeNames) {
                (0, logging_1.log)(`[extractImportsFromFile] Processing type: "${typeName}" from import: "${importPath}"`);
                const importType = determineImportType(typeName, importPath, sourceFile, sourceFiles, projectRoot);
                const isDefault = !!node.importClause?.name && node.importClause.name.text === typeName;
                const importInfo = {
                    typeName,
                    importPath: { [sourceFile.fileName]: importPath },
                    isDefault,
                    importType,
                };
                (0, logging_1.log)(`[extractImportsFromFile] Created ImportInfo:`, importInfo);
                imports.push(importInfo);
            }
        }
    });
    (0, logging_1.log)(`[extractImportsFromFile] Output: ${imports.length} imports extracted`);
    return imports;
};
exports.extractImportsFromFile = extractImportsFromFile;
/**
 * Extracts import information for a specific type from a source file
 *
 * @param sourceFile - The TypeScript source file to search for imports
 * @param typeName - The name of the type to find import information for
 * @param sourceFiles - Optional array of all source files in the project for context
 * @returns ImportInfo object for the specified type, or null if not found
 *
 * @example
 * ```typescript
 * const sourceCode = `
 * import { User, Product } from 'my-package';
 * import Button from '@/components/Button';
 * import type { Config } from './types/Config';
 * `;
 *
 * const sourceFile = ts.createSourceFile('src/components/App.ts', sourceCode, ts.ScriptTarget.Latest);
 * const sourceFiles = []; // array of all source files
 *
 * const userImport = extractImportsFromSourceFile(sourceFile, 'User', sourceFiles);
 * // Returns: {
 * //   typeName: 'User',
 * //   importPath: 'my-package',
 * //   isDefault: false,
 * //   importType: ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD
 * // }
 *
 * const buttonImport = extractImportsFromSourceFile(sourceFile, 'Button', sourceFiles);
 * // Returns: {
 * //   typeName: 'Button',
 * //   importPath: '@/components/Button',
 * //   isDefault: true,
 * //   importType: ImportTypeEnum.FROM_GLOBAL_PATH
 * // }
 *
 * const notFound = extractImportsFromSourceFile(sourceFile, 'NotFound', sourceFiles);
 * // Returns: null
 * ```
 */
const extractImportsFromSourceFile = (sourceFile, typeName, sourceFiles = []) => {
    const projectRoot = process.cwd();
    let result = null;
    ts.forEachChild(sourceFile, (node) => {
        if (result)
            return; // Early exit if we already found the import
        if (ts.isImportDeclaration(node)) {
            const importPath = node.moduleSpecifier.text;
            if (node.importClause) {
                // Check default import: import B from 'path'
                if (node.importClause.name &&
                    node.importClause.name.text === typeName) {
                    const importType = determineImportType(typeName, importPath, sourceFile, sourceFiles, projectRoot);
                    result = {
                        typeName: node.importClause.name.text,
                        importPath: { [sourceFile.fileName]: importPath },
                        isDefault: true,
                        importType,
                    };
                }
                // Check named imports: import { B } from 'path'
                if (!result &&
                    node.importClause.namedBindings &&
                    ts.isNamedImports(node.importClause.namedBindings)) {
                    for (const element of node.importClause.namedBindings.elements) {
                        if (element.name.text === typeName) {
                            const importType = determineImportType(typeName, importPath, sourceFile, sourceFiles, projectRoot);
                            result = {
                                typeName: element.name.text,
                                importPath: { [sourceFile.fileName]: importPath },
                                isDefault: false,
                                importType,
                            };
                            break;
                        }
                    }
                }
                // Check namespace imports: import * as ts from 'typescript'
                if (!result &&
                    node.importClause.namedBindings &&
                    ts.isNamespaceImport(node.importClause.namedBindings)) {
                    const namespaceName = node.importClause.namedBindings.name.text;
                    if (namespaceName === typeName) {
                        const importType = determineImportType(typeName, importPath, sourceFile, sourceFiles, projectRoot);
                        result = {
                            typeName: namespaceName,
                            importPath: { [sourceFile.fileName]: importPath },
                            isDefault: false,
                            importType,
                            isNamespace: true,
                            namespaceName,
                        };
                    }
                }
            }
        }
    });
    return result;
};
exports.extractImportsFromSourceFile = extractImportsFromSourceFile;
// ============================================================================
// IMPORT MAP BUILDING
// ============================================================================
/**
 * Builds a map of type names to their import information across all source files
 *
 * @param sourceFiles - Array of all TypeScript source files in the project
 * @returns Map where keys are type names and values are ImportInfo objects
 *
 * @example
 * ```typescript
 * const sourceFiles = [
 *   ts.createSourceFile('src/components/Button.ts', 'import { User } from "my-package";', ts.ScriptTarget.Latest),
 *   ts.createSourceFile('src/components/App.ts', 'import Button from "@/components/Button";', ts.ScriptTarget.Latest)
 * ];
 *
 * const importMap = buildImportMap(sourceFiles);
 * // Returns: Map {
 * //   'User' => {
 * //     typeName: 'User',
 * //     importPath: 'my-package',
 * //     isDefault: false,
 * //     importType: ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD
 * //   },
 * //   'Button' => {
 * //     typeName: 'Button',
 * //     importPath: '@/components/Button',
 * //     isDefault: true,
 * //     importType: ImportTypeEnum.FROM_GLOBAL_PATH
 * //   }
 * // }
 * ```
 */
const buildImportMap = (sourceFiles) => {
    const importMap = new Map();
    for (const sourceFile of sourceFiles) {
        // Extract imports from import statements
        const imports = (0, exports.extractImportsFromFile)(sourceFile, sourceFiles);
        for (const importInfo of imports) {
            // Skip native types even if they're imported - they should always be treated as native
            if (!isNativeSupportedType(importInfo.typeName)) {
                importMap.set(importInfo.typeName, importInfo);
                (0, logging_1.log)(`[buildImportMap] Adding non-native import: "${importInfo.typeName}" with path: "${JSON.stringify(importInfo.importPath)}"`);
            }
        }
        // Also include types defined in the same file
        ts.forEachChild(sourceFile, (node) => {
            if ((ts.isInterfaceDeclaration(node) ||
                ts.isEnumDeclaration(node) ||
                ts.isTypeAliasDeclaration(node)) &&
                node.name) {
                const typeName = node.name.text;
                if (!importMap.has(typeName)) {
                    const sameFileImportInfo = {
                        typeName,
                        importPath: { [sourceFile.fileName]: '' }, // Same file types don't need import paths
                        isDefault: false,
                        importType: ImportTypeEnum.FROM_SAME_FILE,
                    };
                    importMap.set(typeName, sameFileImportInfo);
                }
            }
        });
        // Also include native types that are used but not imported
        const usedNativeTypes = extractNativeTypesFromFile(sourceFile);
        for (const nativeType of usedNativeTypes) {
            if (!importMap.has(nativeType)) {
                const nativeImportInfo = {
                    typeName: nativeType,
                    importPath: { [sourceFile.fileName]: '' }, // Native types don't need import paths
                    isDefault: false,
                    importType: ImportTypeEnum.FROM_NATIVE,
                };
                importMap.set(nativeType, nativeImportInfo);
            }
        }
    }
    return importMap;
};
exports.buildImportMap = buildImportMap;
// ============================================================================
// NAMESPACE IMPORT HANDLING
// ============================================================================
/**
 * Extracts namespace information from a qualified type name
 *
 * @param qualifiedTypeName - The qualified type name (e.g., 'ts.CompilerOptions')
 * @returns Object with namespace and type name, or null if not namespace-qualified
 *
 * @example
 * ```typescript
 * const result = extractNamespaceFromQualifiedType('ts.CompilerOptions');
 * // Returns: { namespace: 'ts', typeName: 'CompilerOptions' }
 *
 * const result2 = extractNamespaceFromQualifiedType('User');
 * // Returns: null (not namespace-qualified)
 * ```
 */
const extractNamespaceFromQualifiedType = (qualifiedTypeName) => {
    const dotIndex = qualifiedTypeName.indexOf('.');
    if (dotIndex === -1) {
        return null;
    }
    const namespace = qualifiedTypeName.substring(0, dotIndex);
    const typeName = qualifiedTypeName.substring(dotIndex + 1);
    return { namespace, typeName };
};
exports.extractNamespaceFromQualifiedType = extractNamespaceFromQualifiedType;
/**
 * Finds namespace import information for a given namespace name
 *
 * @param namespaceName - The namespace name to find (e.g., 'ts')
 * @param sourceFile - The source file to search in
 * @param sourceFiles - All source files for context
 * @returns ImportInfo for the namespace, or null if not found
 *
 * @example
 * ```typescript
 * const namespaceImport = findNamespaceImport('ts', sourceFile, sourceFiles);
 * // Returns: { typeName: 'ts', importPath: 'typescript', isNamespace: true, ... }
 * ```
 */
const findNamespaceImport = (namespaceName, sourceFile, sourceFiles) => {
    return (0, exports.extractImportsFromSourceFile)(sourceFile, namespaceName, sourceFiles);
};
exports.findNamespaceImport = findNamespaceImport;
// ============================================================================
// NATIVE TYPE DETECTION
// ============================================================================
/**
 * Checks if a type is a native JavaScript/TypeScript type that doesn't need to be imported
 *
 * @param typeName - The name of the type to check (e.g., 'Buffer', 'Promise', 'RegExp')
 * @returns true if the type is a native type, false otherwise
 *
 * @example
 * ```typescript
 * const isNative = isNativeType('Buffer');
 * // Returns: true (Buffer is a native Node.js type)
 *
 * const isNotNative = isNativeType('User');
 * // Returns: false (User is not a native type)
 * ```
 */
const isNativeSupportedType = (typeName) => {
    const nativeTypes = [
        'Map',
        'Set',
        'Date',
        'Error',
        'Function',
        'Object',
        'Array',
        'String',
        'Number',
        'Boolean',
        'BigInt',
        'undefined',
        'null',
        'any',
        'unknown',
        'File',
        'FileList',
        'Blob',
        'FormData',
        'Buffer',
        'Promise',
        'RegExp',
        'Symbol',
        'WeakMap',
        'WeakSet',
        'ArrayBuffer',
        'DataView',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Uint16Array',
        'Int32Array',
        'Uint32Array',
        'Float32Array',
        'Float64Array',
        'BigInt64Array',
        'BigUint64Array',
        'SharedArrayBuffer',
        'Atomics',
        'JSON',
        'Math',
        'EvalError',
        'RangeError',
        'ReferenceError',
        'SyntaxError',
        'TypeError',
        'URIError',
        'AggregateError',
        'URL',
        'URLSearchParams',
        'Headers',
        'Request',
        'Response',
        'Event',
        'EventTarget',
        'CustomEvent',
        'MessageEvent',
        'ErrorEvent',
        'CloseEvent',
        'WebSocket',
        'XMLHttpRequest',
        'AbortController',
        'AbortSignal',
        'ReadableStream',
        'WritableStream',
        'TransformStream',
        'ByteLengthQueuingStrategy',
        'CountQueuingStrategy',
        'TextEncoder',
        'TextDecoder',
        'Crypto',
        'SubtleCrypto',
        'CryptoKey',
        'CryptoKeyPair',
    ];
    return nativeTypes.includes(typeName);
};
/**
 * Extracts native types that are used in a source file but not imported
 *
 * @param sourceFile - The TypeScript source file to analyze
 * @returns Array of native type names that are used in the file
 *
 * @example
 * ```typescript
 * const sourceCode = `
 * export interface User {
 *   id: number;
 *   name: string;
 *   avatar: Buffer; // Buffer is a native type
 *   data: Promise<string>; // Promise is a native type
 * }
 * `;
 *
 * const sourceFile = ts.createSourceFile('src/types.ts', sourceCode, ts.ScriptTarget.Latest);
 * const nativeTypes = extractNativeTypesFromFile(sourceFile);
 * // Returns: ['Buffer', 'Promise']
 * ```
 */
const extractNativeTypesFromFile = (sourceFile) => {
    const nativeTypes = new Set();
    const visitNode = (node) => {
        // Check for type references
        if (ts.isTypeReferenceNode(node)) {
            const typeName = node.typeName.getText();
            if (isNativeSupportedType(typeName)) {
                nativeTypes.add(typeName);
            }
        }
        // Check for type annotations in variable declarations
        if (ts.isVariableDeclaration(node) && node.type) {
            if (ts.isTypeReferenceNode(node.type)) {
                const typeName = node.type.typeName.getText();
                if (isNativeSupportedType(typeName)) {
                    nativeTypes.add(typeName);
                }
            }
        }
        // Check for parameter types in function declarations
        if (ts.isFunctionDeclaration(node) && node.parameters) {
            for (const param of node.parameters) {
                if (param.type && ts.isTypeReferenceNode(param.type)) {
                    const typeName = param.type.typeName.getText();
                    if (isNativeSupportedType(typeName)) {
                        nativeTypes.add(typeName);
                    }
                }
            }
        }
        // Check for return types in function declarations
        if (ts.isFunctionDeclaration(node) && node.type) {
            if (ts.isTypeReferenceNode(node.type)) {
                const typeName = node.type.typeName.getText();
                if (isNativeSupportedType(typeName)) {
                    nativeTypes.add(typeName);
                }
            }
        }
        // Check for property types in interface declarations
        if (ts.isInterfaceDeclaration(node)) {
            for (const member of node.members) {
                if (ts.isPropertySignature(member) && member.type) {
                    if (ts.isTypeReferenceNode(member.type)) {
                        const typeName = member.type.typeName.getText();
                        if (isNativeSupportedType(typeName)) {
                            nativeTypes.add(typeName);
                        }
                    }
                }
            }
        }
        // Check for property types in type alias declarations
        if (ts.isTypeAliasDeclaration(node) && node.type) {
            if (ts.isTypeReferenceNode(node.type)) {
                const typeName = node.type.typeName.getText();
                if (isNativeSupportedType(typeName)) {
                    nativeTypes.add(typeName);
                }
            }
        }
        // Continue visiting children
        ts.forEachChild(node, visitNode);
    };
    visitNode(sourceFile);
    return Array.from(nativeTypes);
};
// ============================================================================
// DEFAULT EXPORT DETECTION
// ============================================================================
/**
 * Checks if a type is exported as default from a source file
 *
 * @param typeName - The name of the type to check (e.g., 'User', 'Product')
 * @param sourceFile - The TypeScript source file to search in
 * @returns true if the type is exported as default, false otherwise
 *
 * @example
 * ```typescript
 * // For a file with default export:
 * const sourceCode = `
 * export default interface User {
 *   id: string;
 *   name: string;
 * }
 * `;
 *
 * const sourceFile = ts.createSourceFile('src/types/User.ts', sourceCode, ts.ScriptTarget.Latest);
 * const isDefault = isDefaultExport('User', sourceFile);
 * // Returns: true
 *
 * // For a file with named export:
 * const sourceCode2 = `
 * export interface Product {
 *   id: string;
 *   name: string;
 * }
 * `;
 *
 * const sourceFile2 = ts.createSourceFile('src/types/Product.ts', sourceCode2, ts.ScriptTarget.Latest);
 * const isDefault2 = isDefaultExport('Product', sourceFile2);
 * // Returns: false
 *
 * // For a file with export default assignment:
 * const sourceCode3 = `
 * interface Config {
 *   apiUrl: string;
 * }
 *
 * export default Config;
 * `;
 *
 * const sourceFile3 = ts.createSourceFile('src/types/Config.ts', sourceCode3, ts.ScriptTarget.Latest);
 * const isDefault3 = isDefaultExport('Config', sourceFile3);
 * // Returns: true
 * ```
 */
const isDefaultExport = (typeName, sourceFile) => {
    let isDefault = false;
    ts.forEachChild(sourceFile, (node) => {
        // Check for default export on interface/type declarations
        if ((ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) &&
            node.name &&
            node.name.text === typeName) {
            // Check for DefaultKeyword by string value as fallback
            if (node.modifiers &&
                node.modifiers.some(mod => mod.getText() === 'default')) {
                isDefault = true;
            }
        }
        // Check for export default assignments
        if (ts.isExportAssignment(node) && node.expression) {
            // Check for export default TypeName
            if (ts.isIdentifier(node.expression) &&
                node.expression.text === typeName) {
                isDefault = true;
            }
            // Check for export default { TypeName }
            if (ts.isObjectLiteralExpression(node.expression)) {
                node.expression.properties.forEach(prop => {
                    if (ts.isShorthandPropertyAssignment(prop) &&
                        prop.name.text === typeName) {
                        isDefault = true;
                    }
                });
            }
        }
        // Check for export default interface/type with modifiers
        if ((ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) &&
            node.name &&
            node.name.text === typeName &&
            node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword) &&
            node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.DefaultKeyword)) {
            isDefault = true;
        }
        // Check for export default interface/type (alternative syntax)
        if ((ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) &&
            node.name &&
            node.name.text === typeName &&
            node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.DefaultKeyword)) {
            isDefault = true;
        }
    });
    // Fallback: check for 'export default interface <typeName>' or 'export default type <typeName>' in the file text
    if (!isDefault) {
        const fileText = sourceFile.getFullText();
        if (fileText.includes(`export default interface ${typeName}`) ||
            fileText.includes(`export default type ${typeName}`)) {
            isDefault = true;
        }
    }
    return isDefault;
};
exports.isDefaultExport = isDefaultExport;
//# sourceMappingURL=import-extractors.js.map