"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildImportStatementsOptimized = exports.buildImportStatements = exports.buildTypeGuardImportInfo = exports.clearImportStrategyCache = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const ts = __importStar(require("typescript"));
const logging_1 = require("../logging");
const types_1 = require("../types");
const import_extractors_1 = require("./import-extractors");
const import_strategy_1 = require("./import-strategy");
const path_resolvers_1 = require("./path-resolvers");
const type_collectors_1 = require("./type-collectors");
/**
 * Cache for import strategy results to avoid recomputation
 */
const importStrategyCache = new Map();
/**
 * Clears the import strategy cache
 * Should be called at the start of each generation run
 */
const clearImportStrategyCache = () => {
    const cacheSize = importStrategyCache.size;
    importStrategyCache.clear();
    (0, logging_1.logDebug)('Cleared import strategy cache', { previousCacheSize: cacheSize });
};
exports.clearImportStrategyCache = clearImportStrategyCache;
/**
 * Gets cached import strategy result or computes and caches it
 */
const getCachedImportStrategy = (cacheKey, importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, context, currentSourceFile, typeGuardCode) => {
    // Check if we have a cached result
    if (importStrategyCache.has(cacheKey)) {
        (0, logging_1.logDebug)('Cache hit - using cached import strategy', {
            cacheKey: cacheKey.substring(0, 100) + '...',
            cacheSize: importStrategyCache.size,
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return importStrategyCache.get(cacheKey);
    }
    // Calculate needsTypeGuardFnConfigImport from typeGuardCode
    const needsTypeGuardFnConfigImport = typeGuardCode
        ? (0, type_collectors_1.needsTypeGuardFnConfig)(typeGuardCode)
        : false;
    (0, logging_1.logDebug)('Cache miss - executing import strategy', {
        cacheKey: cacheKey.substring(0, 100) + '...',
        importTypesCount: importTypes.length,
        usedEnumsCount: usedEnums.length,
        usedGuardzUtilitiesCount: usedGuardzUtilities.length,
        usedTypeGuardsCount: usedTypeGuards.length,
        usedGuardzTypeAliasesCount: usedGuardzTypeAliases.length,
        needsTypeGuardFnImport,
        needsTypeGuardFnConfigImport,
        currentSourceFile: currentSourceFile?.fileName,
    });
    const result = (0, import_strategy_1.executeImportStrategy)(importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, needsTypeGuardFnConfigImport, {
        outputDir: context.outputDir,
        sourceFiles: context.sourceFiles,
        importMap: context.importMap,
        currentSourceFile,
    }, buildTypeImportInfo, exports.buildTypeGuardImportInfo);
    importStrategyCache.set(cacheKey, result);
    (0, logging_1.logDebug)('Cached import strategy result', {
        cacheKey: cacheKey.substring(0, 100) + '...',
        resultImportsCount: result.importItems.length,
        hasEnums: false, // We'll need to track this differently if needed
    });
    (0, logging_1.logEmptyLines)();
    return result;
};
/**
 * Groups imports by module and combines named imports to generate optimized import statements
 *
 * @param imports - Array of ImportItem objects representing individual imports
 * @returns Array of formatted import statements
 *
 * @example
 * ```typescript
 * const imports = [
 *   { name: 'User', path: './types/User', isType: true, isDefault: false },
 *   { name: 'Product', path: './types/User', isType: true, isDefault: false },
 *   { name: 'isUser', path: './guards/isUser', isType: false, isDefault: false },
 *   { name: 'default', path: './utils/helper', isType: false, isDefault: true }
 * ];
 *
 * const statements = groupImportsByModule(imports, "'");
 * // Returns: [
 * //   "import type { User, Product } from './types/User';",
 * //   "import { isUser } from './guards/isUser';",
 * //   "import type default from './utils/helper';"
 * // ]
 * ```
 */
const groupImportsByModule = (imports) => {
    const quote = "'";
    (0, logging_1.logDebug)(`[groupImportsByModule] Input: imports.length = ${imports.length}`);
    (0, logging_1.logDebug)(`[groupImportsByModule] Import items:`, imports);
    (0, logging_1.logDebug)(`[groupImportsByModule] Starting import grouping process`);
    const moduleGroups = new Map();
    for (const importItem of imports) {
        (0, logging_1.logDebug)(`[groupImportsByModule] Processing import item:`, importItem);
        // Remove .ts extension from import paths
        const originalPath = importItem.path;
        const modulePath = importItem.path.replace(/\.ts$/, '');
        if (originalPath !== modulePath) {
            (0, logging_1.logDebug)(`[groupImportsByModule] Modified import path for "${importItem.name}": "${originalPath}" -> "${modulePath}" (touch count: ${importItem.touchCount || 1})`);
        }
        if (!moduleGroups.has(modulePath)) {
            (0, logging_1.logDebug)(`[groupImportsByModule] Creating new group for path: "${modulePath}"`);
            moduleGroups.set(modulePath, {
                types: [],
                values: [],
                defaults: [],
                namespaces: [],
            });
        }
        const group = moduleGroups.get(modulePath);
        if (!group)
            continue;
        if (importItem.isDefault) {
            group.defaults.push(importItem.name);
            (0, logging_1.logDebug)(`[groupImportsByModule] Added default import: "${importItem.name}" to group: "${modulePath}"`);
        }
        else if (importItem.isNamespace) {
            group.namespaces.push(importItem.name);
            (0, logging_1.logDebug)(`[groupImportsByModule] Added namespace import: "${importItem.name}" to group: "${modulePath}"`);
        }
        else if (importItem.isType) {
            group.types.push(importItem.name);
            (0, logging_1.logDebug)(`[groupImportsByModule] Added type import: "${importItem.name}" to group: "${modulePath}"`);
        }
        else {
            group.values.push(importItem.name);
            (0, logging_1.logDebug)(`[groupImportsByModule] Added value import: "${importItem.name}" to group: "${modulePath}"`);
        }
    }
    (0, logging_1.logDebug)(`[groupImportsByModule] Module groups:`, Object.fromEntries(moduleGroups));
    (0, logging_1.logDebug)(`[groupImportsByModule] Total module groups: ${moduleGroups.size}`);
    const result = [];
    (0, logging_1.logDebug)(`[groupImportsByModule] Starting to generate import statements`);
    for (const [modulePath, group] of Array.from(moduleGroups.entries())) {
        (0, logging_1.logDebug)(`[groupImportsByModule] Processing module: "${modulePath}" with group:`, group);
        const statements = [];
        // Add default imports (deduplicated)
        const uniqueDefaults = Array.from(new Set(group.defaults));
        (0, logging_1.logDebug)(`[groupImportsByModule] Unique defaults for "${modulePath}": [${uniqueDefaults.join(', ')}]`);
        for (const defaultName of uniqueDefaults) {
            const statement = `import type ${defaultName} from ${quote}${modulePath}${quote};`;
            statements.push(statement);
            (0, logging_1.logDebug)(`[groupImportsByModule] Added default import statement: "${statement}"`);
        }
        // Add type imports (deduplicated)
        if (group.types.length > 0) {
            const uniqueTypes = Array.from(new Set(group.types));
            (0, logging_1.logDebug)(`[groupImportsByModule] Unique types for "${modulePath}": [${uniqueTypes.join(', ')}]`);
            if (uniqueTypes.length === 1) {
                const statement = `import type { ${uniqueTypes[0]} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
                (0, logging_1.logDebug)(`[groupImportsByModule] Added single type import statement: "${statement}"`);
            }
            else {
                const statement = `import type { ${uniqueTypes.join(', ')} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
                (0, logging_1.logDebug)(`[groupImportsByModule] Added multiple type import statement: "${statement}"`);
            }
        }
        // Add namespace imports (deduplicated)
        if (group.namespaces.length > 0) {
            const uniqueNamespaces = Array.from(new Set(group.namespaces));
            (0, logging_1.logDebug)(`[groupImportsByModule] Unique namespaces for "${modulePath}": [${uniqueNamespaces.join(', ')}]`);
            for (const namespaceName of uniqueNamespaces) {
                const statement = `import type * as ${namespaceName} from ${quote}${modulePath}${quote};`;
                statements.push(statement);
                (0, logging_1.logDebug)(`[groupImportsByModule] Added namespace import statement: "${statement}"`);
            }
        }
        // Add value imports (deduplicated)
        if (group.values.length > 0) {
            const uniqueValues = Array.from(new Set(group.values));
            (0, logging_1.logDebug)(`[groupImportsByModule] Unique values for "${modulePath}": [${uniqueValues.join(', ')}]`);
            if (uniqueValues.length === 1) {
                const statement = `import { ${uniqueValues[0]} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
                (0, logging_1.logDebug)(`[groupImportsByModule] Added single value import statement: "${statement}"`);
            }
            else {
                const statement = `import { ${uniqueValues.join(', ')} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
                (0, logging_1.logDebug)(`[groupImportsByModule] Added multiple value import statement: "${statement}"`);
            }
        }
        result.push(...statements);
    }
    (0, logging_1.logDebug)(`[groupImportsByModule] Output: ${result.length} import statements generated`);
    (0, logging_1.logDebug)(`[groupImportsByModule] Generated statements:`, result);
    return result;
};
// Check if a type is a guardz type alias
const isGuardzTypeAlias = (typeName) => {
    const guardzTypeAliases = [
        'NonEmptyArray',
        'NonEmptyString',
        'NonNegativeNumber',
        'PositiveNumber',
        'Nullable',
        'TypeGuardFn',
        'TypeGuardFnConfig',
        'Numeric',
        'BooleanLike',
        'DateLike',
    ];
    return guardzTypeAliases.includes(typeName);
};
/**
 * Builds import information for a specific type, determining the correct import path and format
 *
 * @param type - The name of the type to import (e.g., 'User', 'Product', 'Buffer')
 * @param context - The import strategy context containing source files and configuration
 * @returns ImportItem with import details or null if the type should not be imported
 *
 * @example
 * ```typescript
 * const context = {
 *   sourceFiles: [], // array of source files
 *   outputDir: '/path/to/output',
 *   currentSourceFile: ts.createSourceFile('src/components/App.ts', '', ts.ScriptTarget.Latest)
 * };
 *
 * // For a node module type
 * const nodeModuleImport = buildTypeImportInfo('Buffer', context);
 * // Returns: { name: 'Buffer', path: 'buffer', isType: true, isDefault: false }
 *
 * // For a local type
 * const localImport = buildTypeImportInfo('User', context);
 * // Returns: { name: 'User', path: './types/User', isType: true, isDefault: false }
 *
 * // For a type defined in current file
 * const currentFileImport = buildTypeImportInfo('LocalType', context);
 * // Returns: null (no import needed)
 * ```
 */
const buildTypeImportInfo = (type, context) => {
    (0, logging_1.logDebug)(`[buildTypeImportInfo] Input: type = "${type}", context.outputDir = "${context.outputDir}", context.currentSourceFile?.fileName = "${context.currentSourceFile?.fileName}"`);
    // Check if this is a namespace-qualified type (e.g., 'ts.CompilerOptions')
    const namespaceInfo = (0, import_extractors_1.extractNamespaceFromQualifiedType)(type);
    if (namespaceInfo) {
        (0, logging_1.logDebug)(`[buildTypeImportInfo] Namespace-qualified type detected: "${type}" -> namespace: "${namespaceInfo.namespace}", typeName: "${namespaceInfo.typeName}"`);
        // Find the namespace import
        if (context.currentSourceFile) {
            const namespaceImport = (0, import_extractors_1.findNamespaceImport)(namespaceInfo.namespace, context.currentSourceFile, context.sourceFiles);
            if (namespaceImport && namespaceImport.isNamespace) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Found namespace import: "${namespaceInfo.namespace}" from "${namespaceImport.importPath}"`);
                // Import the namespace
                const importPath = Object.values(namespaceImport.importPath)[0] || '';
                const result = {
                    name: namespaceInfo.namespace,
                    path: importPath,
                    isType: false, // Namespace imports are not type imports
                    isDefault: false,
                    isNamespace: true,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
        }
        (0, logging_1.logDebug)(`[buildTypeImportInfo] No namespace import found for "${namespaceInfo.namespace}", treating as regular type`);
    }
    // Check if this is a guardz type alias first
    if (isGuardzTypeAlias(type)) {
        (0, logging_1.logDebug)(`[buildTypeImportInfo] Guardz type alias detected: "${type}", importing from 'guardz'`);
        const result = {
            name: type,
            path: 'guardz',
            isType: true,
            isDefault: false,
        };
        (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
        return result;
    }
    // If we have a current source file, try to find the import info from it first
    const currentSourceFile = context.currentSourceFile;
    if (currentSourceFile) {
        (0, logging_1.logDebug)(`[buildTypeImportInfo] Current source file found: "${currentSourceFile.fileName}"`);
        const importInfo = (0, import_extractors_1.extractImportsFromSourceFile)(currentSourceFile, type, context.sourceFiles);
        if (importInfo) {
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Found import info:`, importInfo);
            // For same file types, import the type from the original source file
            if (importInfo.importType === import_extractors_1.ImportTypeEnum.FROM_SAME_FILE) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Same file type detected, importing type from original source file: "${type}"`);
                // Import the type from the original source file (not the type guard file)
                const originalSourcePath = path
                    .relative(context.outputDir, currentSourceFile.fileName)
                    .replace(/\\/g, '/')
                    .replace(/\.ts$/, '');
                const sourcePath = `./${originalSourcePath}`;
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Original source path: "${sourcePath}"`);
                const result = {
                    name: type,
                    path: sourcePath,
                    isType: true,
                    isDefault: false,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
            // For native types, don't import anything (they're globally available)
            if (importInfo.importType === import_extractors_1.ImportTypeEnum.FROM_NATIVE) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Native type detected, no import needed: "${type}"`);
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output: null`);
                return null;
            }
            // For node modules, we still need to import the type, but we don't generate type guards for it
            if (importInfo.importType ===
                import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD ||
                importInfo.importType ===
                    import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES ||
                importInfo.importType ===
                    import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL) {
                // Get the import path for the current source file, or use the first available path
                const importPath = currentSourceFile && importInfo.importPath[currentSourceFile.fileName]
                    ? importInfo.importPath[currentSourceFile.fileName]
                    : Object.values(importInfo.importPath)[0] || '';
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Node module import detected, importing type from: "${importPath}"`);
                // Import the type from node modules
                const result = {
                    name: type,
                    path: importPath,
                    isType: true,
                    isDefault: importInfo.isDefault,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
            // Get the import path for the current source file, or use the first available path
            const importPath = currentSourceFile && importInfo.importPath[currentSourceFile.fileName]
                ? importInfo.importPath[currentSourceFile.fileName]
                : Object.values(importInfo.importPath)[0] || '';
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Local import detected, processing path: "${importPath}"`);
            // For local imports, use the same path resolution logic as copyOriginalImports
            const originalPath = importPath;
            if (originalPath.startsWith('.')) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Relative path detected: "${originalPath}"`);
                // Use the same logic as resolveImportPath in import-strategy.ts
                const basePath = originalPath.replace(/\.(ts|js|tsx|jsx)$/, '');
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Base path: "${basePath}"`);
                // Preserve .type and .types suffixes for type imports
                const relativePath = path
                    .relative(context.outputDir, path.resolve(path.dirname(currentSourceFile.fileName), basePath))
                    .replace(/\\/g, '/');
                const relPath = (0, path_resolvers_1.cleanImportPath)('./' + relativePath);
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Relative path resolved: "${relPath}"`);
                // Find the actual source file to check for default export
                const actualSourceFile = context.sourceFiles.find(sf => sf.fileName ===
                    path.resolve(path.dirname(currentSourceFile.fileName), basePath + '.ts'));
                const isDefault = actualSourceFile
                    ? (0, import_extractors_1.isDefaultExport)(type, actualSourceFile)
                    : importInfo.isDefault;
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Is default export: ${isDefault}`);
                if ((0, types_1.isEnumType)(type, context.sourceFiles)) {
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is enum, importing as value`);
                    const result = {
                        name: type,
                        path: relPath,
                        isType: false,
                        isDefault: false,
                    };
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                    return result;
                }
                else if (isDefault) {
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is default export`);
                    const result = {
                        name: type,
                        path: relPath,
                        isType: true,
                        isDefault: true,
                    };
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                    return result;
                }
                else {
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is named export`);
                    const result = {
                        name: type,
                        path: relPath,
                        isType: true,
                        isDefault: false,
                    };
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                    return result;
                }
            }
            else {
                // For non-relative paths (like global paths), use as-is
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Non-relative path detected: "${originalPath}"`);
                const result = {
                    name: type,
                    path: originalPath,
                    isType: true,
                    isDefault: false,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
        }
        (0, logging_1.logDebug)(`[buildTypeImportInfo] No import info found, checking if type is defined in current file`);
        // If no import info found, check if the type is defined in the current source file
        let isDefinedInCurrentFile = false;
        ts.forEachChild(currentSourceFile, (node) => {
            if ((ts.isInterfaceDeclaration(node) ||
                ts.isEnumDeclaration(node) ||
                ts.isTypeAliasDeclaration(node)) &&
                node.name &&
                node.name.text === type) {
                isDefinedInCurrentFile = true;
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Found type definition in current file: ${node.kind}`);
            }
        });
        // If the type is defined in the current source file, import the type from the original source file
        if (isDefinedInCurrentFile) {
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is defined in current file, importing type from original source file: "${type}"`);
            // Check if this type is a default export
            const isDefault = (0, import_extractors_1.isDefaultExport)(type, currentSourceFile);
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Is default export: ${isDefault}`);
            // Check if this type is an enum - enums should be imported as values, not types
            const isEnum = (0, types_1.isEnumType)(type, context.sourceFiles);
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Is enum: ${isEnum}`);
            // Import the type from the original source file (not the type guard file)
            const originalSourcePath = path
                .relative(context.outputDir, currentSourceFile.fileName)
                .replace(/\\/g, '/')
                .replace(/\.ts$/, '');
            const sourcePath = `./${originalSourcePath}`;
            (0, logging_1.logDebug)(`[buildTypeImportInfo] Original source path: "${sourcePath}"`);
            if (isEnum) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is enum, importing as value`);
                const result = {
                    name: type,
                    path: sourcePath,
                    isType: false,
                    isDefault: false,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
            else if (isDefault) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is default export`);
                const result = {
                    name: type,
                    path: sourcePath,
                    isType: true,
                    isDefault: true,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
            else {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Type is named export`);
                const result = {
                    name: type,
                    path: sourcePath,
                    isType: true,
                    isDefault: false,
                };
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                return result;
            }
        }
    }
    // If we don't have a current source file, try to find the type in all source files
    if (context.sourceFiles) {
        (0, logging_1.logDebug)(`[buildTypeImportInfo] No current source file, searching in all source files`);
        for (const sourceFile of context.sourceFiles) {
            const importInfo = (0, import_extractors_1.extractImportsFromSourceFile)(sourceFile, type, context.sourceFiles);
            if (importInfo) {
                (0, logging_1.logDebug)(`[buildTypeImportInfo] Found import info in source file:`, importInfo);
                // Use the first available import path
                const importPath = Object.values(importInfo.importPath)[0] || '';
                if (importPath) {
                    const result = {
                        name: type,
                        path: importPath,
                        isType: true,
                        isDefault: importInfo.isDefault,
                    };
                    (0, logging_1.logDebug)(`[buildTypeImportInfo] Output:`, result);
                    return result;
                }
            }
        }
    }
    (0, logging_1.logDebug)(`[buildTypeImportInfo] Type not found anywhere`);
    (0, logging_1.logDebug)(`[buildTypeImportInfo] Output: null`);
    return null;
};
// Build type guard import info with the new context interface
/**
 * Builds import information for a type guard function, determining the correct import path
 *
 * @param name - The name of the type guard function (e.g., 'isUser', 'isProduct')
 * @param context - The import strategy context containing source files and configuration
 * @returns ImportItem with import details or null if the type guard should not be imported
 *
 * @example
 * ```typescript
 * const context = {
 *   sourceFiles: [], // array of source files
 *   outputDir: '/path/to/output',
 *   currentSourceFile: ts.createSourceFile('src/components/App.ts', '', ts.ScriptTarget.Latest)
 * };
 *
 * // For a local type guard
 * const localGuard = buildTypeGuardImportInfo('isUser', context);
 * // Returns: { name: 'isUser', path: './isUser.guardz', isType: false, isDefault: false }
 *
 * // For a type guard from a different directory
 * const nestedGuard = buildTypeGuardImportInfo('isProduct', context);
 * // Returns: { name: 'isProduct', path: './types/isProduct.guardz', isType: false, isDefault: false }
 *
 * // For a non-existent type guard
 * const missingGuard = buildTypeGuardImportInfo('isNonExistent', context);
 * // Returns: null
 * ```
 */
const buildTypeGuardImportInfo = (name, context) => {
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Input: name = "${name}", context.outputDir = "${context.outputDir}", context.currentSourceFile?.fileName = "${context.currentSourceFile?.fileName}"`);
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Processing type guard: "${name}"`);
    // Extract the base type name from the type guard name (e.g., isPrimitiveTypes â†’ PrimitiveTypes)
    let baseTypeName = name;
    if (/^is[A-Z]/.test(name)) {
        baseTypeName = name.slice(2);
        baseTypeName = baseTypeName.charAt(0).toUpperCase() + baseTypeName.slice(1);
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Extracted base type name: "${baseTypeName}" from guard name: "${name}"`);
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Guard name does not match pattern, using as-is: "${baseTypeName}"`);
    }
    // Check if this is a native type that doesn't need a type guard import
    const nativeTypes = [
        'Buffer',
        'Promise',
        'RegExp',
        'Symbol',
        'WeakMap',
        'WeakSet',
        'Map',
        'Set',
        'ArrayBuffer',
        'DataView',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Uint16Array',
        'Int32Array',
        'Uint32Array',
        'Float32Array',
        'Float64Array',
        'BigInt64Array',
        'BigUint64Array',
        'SharedArrayBuffer',
        'Atomics',
        'JSON',
        'Math',
        'Date',
        'Error',
        'EvalError',
        'RangeError',
        'ReferenceError',
        'SyntaxError',
        'TypeError',
        'URIError',
        'AggregateError',
        'Function',
        'Object',
        'Array',
        'String',
        'Number',
        'Boolean',
        'Symbol',
        'BigInt',
        'undefined',
        'null',
        'void',
        'never',
        'any',
        'unknown',
        'File',
        'FileList',
        'Blob',
        'FormData',
        'URL',
        'URLSearchParams',
        'Headers',
        'Request',
        'Response',
        'Event',
        'EventTarget',
        'CustomEvent',
        'MessageEvent',
        'ErrorEvent',
        'CloseEvent',
        'WebSocket',
        'XMLHttpRequest',
        'AbortController',
        'AbortSignal',
        'ReadableStream',
        'WritableStream',
        'TransformStream',
        'ByteLengthQueuingStrategy',
        'CountQueuingStrategy',
        'TextEncoder',
        'TextDecoder',
        'Crypto',
        'SubtleCrypto',
        'CryptoKey',
        'CryptoKeyPair',
    ];
    if (nativeTypes.includes(baseTypeName)) {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Native type detected: "${baseTypeName}", returning null for isAsserted usage`);
        return null;
    }
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Not a native type, proceeding with import resolution for: "${baseTypeName}"`);
    // PRIORITY 1: Check if the type is defined in the current source file (same-file types)
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] PRIORITY 1: Checking if type is defined in current source file`);
    if (context.currentSourceFile) {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Current source file: "${context.currentSourceFile.fileName}"`);
        let isDefinedInCurrentFile = false;
        let foundNodeType = '';
        ts.forEachChild(context.currentSourceFile, (node) => {
            if ((ts.isInterfaceDeclaration(node) ||
                ts.isEnumDeclaration(node) ||
                ts.isTypeAliasDeclaration(node)) &&
                node.name &&
                node.name.text === baseTypeName) {
                isDefinedInCurrentFile = true;
                foundNodeType = ts.SyntaxKind[node.kind];
                (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Found type definition in current file: ${foundNodeType} "${baseTypeName}"`);
            }
        });
        if (isDefinedInCurrentFile) {
            const result = {
                name,
                path: `./${name}.guardz`,
                isType: false,
                isDefault: false,
                touchCount: 1,
            };
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] PRIORITY 1 SUCCESS: Type defined in current file, returning:`, result);
            return result;
        }
        else {
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] PRIORITY 1 FAILED: Type "${baseTypeName}" not found in current file`);
        }
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] PRIORITY 1 SKIPPED: No current source file available`);
    }
    // PRIORITY 2: Check if there's an existing type guard in the same directory as current source file
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] PRIORITY 2: Checking for existing type guard in same directory`);
    if (context.currentSourceFile) {
        const currentDir = path.dirname(context.currentSourceFile.fileName);
        const sameDirGuardPath = path.join(currentDir, `${name}.guardz.ts`);
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Looking for existing guard file: "${sameDirGuardPath}"`);
        if (fs.existsSync(sameDirGuardPath)) {
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] [${name}] Found existing guard file: "${sameDirGuardPath}"`);
            // Only use existing guard if the type is defined in the current source file
            let isDefinedInCurrentFile = false;
            ts.forEachChild(context.currentSourceFile, (node) => {
                if ((ts.isInterfaceDeclaration(node) ||
                    ts.isEnumDeclaration(node) ||
                    ts.isTypeAliasDeclaration(node)) &&
                    node.name &&
                    node.name.text === baseTypeName) {
                    isDefinedInCurrentFile = true;
                    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Type "${baseTypeName}" is defined in current file, can use existing guard`);
                }
            });
            if (isDefinedInCurrentFile) {
                // Use relative path for existing guard in same directory
                const importPath = (0, path_resolvers_1.getTypeGuardImportPathFromFile)(sameDirGuardPath, context.outputDir);
                const result = {
                    name,
                    path: importPath,
                    isType: false,
                    isDefault: false,
                    touchCount: 1,
                };
                (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 2 SUCCESS: Using existing guard file, returning:`, result);
                return result;
            }
            else {
                (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 2 FAILED: Type "${baseTypeName}" not defined in current file, cannot use existing guard`);
            }
        }
        else {
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 2 SKIPPED: No existing guard file found at "${sameDirGuardPath}"`);
        }
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 2 SKIPPED: No current source file available`);
    }
    // PRIORITY 3: Use getTypeGuardImportPath for type guard imports - this will follow the original import path
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 3: Using getTypeGuardImportPath with import map`);
    if (context.importMap) {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Import map available, size: ${context.importMap.size}`);
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Looking for base type name: "${baseTypeName}" in import map`);
        const importPath = (0, path_resolvers_1.getTypeGuardImportPath)(baseTypeName, // Use baseTypeName instead of name (which is the type guard name)
        context.importMap, context.outputDir, context.sourceFiles, context.currentSourceFile);
        if (importPath) {
            const result = {
                name,
                path: importPath,
                isType: false,
                isDefault: false,
                touchCount: 1,
            };
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 3 SUCCESS: Found import path via getTypeGuardImportPath, returning:`, result);
            return result;
        }
        else {
            (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 3 FAILED: getTypeGuardImportPath returned null, propagating null for isAsserted usage`);
            // If importPath is null, propagate null to signal isAsserted usage
            return null;
        }
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 3 SKIPPED: No import map available`);
    }
    // PRIORITY 4: Check for existing type guards in the project (global search)
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 4: Searching for existing type guards in project (global search)`);
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Searching for type guard: "${name}" (base type: "${baseTypeName}")`);
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Source files count: ${context.sourceFiles.length}`);
    const localGuard = (0, types_1.findTypeGuardInProject)(baseTypeName, context.sourceFiles, process.cwd());
    if (localGuard) {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Found existing type guard in project:`, localGuard);
        const importPath = (0, path_resolvers_1.getTypeGuardImportPathFromFile)(localGuard.filePath, context.outputDir);
        const result = {
            name,
            path: importPath,
            isType: false,
            isDefault: false,
            touchCount: 1,
        };
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 4 SUCCESS: Using existing project guard, returning:`, result);
        return result;
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 4 FAILED: No existing type guard found in project for "${baseTypeName}"`);
    }
    // PRIORITY 5: Fallback to finding the source file and calculating relative path
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 5: Finding source file and calculating relative path`);
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Searching for source file containing type: "${baseTypeName}"`);
    const typeSourceFile = (0, types_1.findTypeSourceFile)(baseTypeName, context.sourceFiles);
    if (typeSourceFile) {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Found source file: "${typeSourceFile}"`);
        const relativePath = path
            .relative(context.outputDir, typeSourceFile)
            .replace(/\\/g, '/')
            .replace(/\.ts$/, '');
        const relPath = (0, path_resolvers_1.cleanImportPath)('./' + relativePath);
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] Calculated relative path: "${relPath}"`);
        const result = {
            name,
            path: `${relPath}.guardz`,
            isType: false,
            isDefault: false,
            touchCount: 1,
        };
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 5 SUCCESS: Using source file path, returning:`, result);
        return result;
    }
    else {
        (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 5 FAILED: No source file found for type "${baseTypeName}"`);
    }
    // PRIORITY 6: If no source file found, use the default location
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 6: Using default location (fallback)`);
    const guardFile = `${name}.guardz`;
    const relativePath = path
        .relative(context.outputDir, path.join(context.outputDir, guardFile))
        .replace(/\\/g, '/')
        .replace(/\.ts$/, '');
    const relPath = (0, path_resolvers_1.cleanImportPath)('./' + relativePath);
    const result = {
        name,
        path: relPath,
        isType: false,
        isDefault: false,
        touchCount: 1,
    };
    (0, logging_1.logDebug)(`[buildTypeGuardImportInfo] PRIORITY 6 SUCCESS: Using default location, returning:`, result);
    return result;
};
exports.buildTypeGuardImportInfo = buildTypeGuardImportInfo;
// Main refactored buildImportStatements function
/**
 * Builds complete import statements for a type guard file, including types, utilities, and type guards
 *
 * @param importTypes - Array of type names that need to be imported (e.g., ['User', 'Product'])
 * @param usedEnums - Array of enum names that need to be imported (e.g., ['UserRole', 'ProductStatus'])
 * @param usedGuardzUtilities - Array of guardz utility function names (e.g., ['isString', 'isNumber'])
 * @param usedTypeGuards - Array of local type guard function names (e.g., ['isUser', 'isProduct'])
 * @param usedGuardzTypeAliases - Array of guardz type alias names (e.g., ['TypeGuardFn', 'GuardResult'])
 * @param needsTypeGuardFnImport - Whether to import the TypeGuardFn type from guardz
 * @param outputDir - The output directory where the type guard file will be generated
 * @param sourceFiles - Array of all TypeScript source files in the project
 * @param importMap - Optional map of type names to their import information
 * @param currentSourceFile - Optional current source file for relative path resolution
 * @param typeGuardCode - Optional type guard code to analyze for additional imports
 * @returns Formatted string containing all necessary import statements
 *
 * @example
 * ```typescript
 * const importTypes = ['User', 'Product'];
 * const usedEnums = ['UserRole'];
 * const usedGuardzUtilities = ['isString', 'isNumber', 'isType'];
 * const usedTypeGuards = ['isUser', 'isProduct'];
 * const usedGuardzTypeAliases = ['TypeGuardFn'];
 *
 * const importStatements = buildImportStatements(
 *   importTypes,
 *   usedEnums,
 *   usedGuardzUtilities,
 *   usedTypeGuards,
 *   usedGuardzTypeAliases,
 *   true,
 *   '/path/to/output',
 *   sourceFiles,
 *   importMap,
 *   currentSourceFile,
 *   'single'
 * );
 *
 * // Returns a string like:
 * // "import type { User } from './types/User';
 * //  import type { Product } from './types/Product';
 * //  import type { UserRole } from './enums/UserRole';
 * //  import { isString, isNumber, isType, TypeGuardFn } from 'guardz';
 * //  import { isUser } from './isUser.guardz';
 * //  import { isProduct } from './isProduct.guardz';"
 * ```
 */
const buildImportStatements = (importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, outputDir, sourceFiles, importMap, currentSourceFile, typeGuardCode) => {
    // Create the import strategy context
    const context = {
        outputDir,
        sourceFiles,
        importMap,
    };
    // Execute the import strategy
    const result = getCachedImportStrategy(`${importTypes.join(',')}-${usedEnums.join(',')}-${usedGuardzUtilities.join(',')}-${usedTypeGuards.join(',')}-${usedGuardzTypeAliases.join(',')}-${needsTypeGuardFnImport}-${typeGuardCode ? (0, type_collectors_1.needsTypeGuardFnConfig)(typeGuardCode) : false}-${typeGuardCode || ''}`, importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, context, currentSourceFile, typeGuardCode);
    // Group imports by module and build statements
    const groupedImports = groupImportsByModule(result.importItems);
    return groupedImports.join('\n');
};
exports.buildImportStatements = buildImportStatements;
/**
 * Optimized version of buildImportStatements that uses shared context
 * This version is more efficient for batch processing multiple files
 *
 * @param importTypes - Array of type names that need to be imported
 * @param usedEnums - Array of enum names that need to be imported
 * @param usedGuardzUtilities - Array of guardz utility function names
 * @param usedTypeGuards - Array of local type guard function names
 * @param usedGuardzTypeAliases - Array of guardz type alias names
 * @param needsTypeGuardFnImport - Whether to import the TypeGuardFn type from guardz
 * @param sharedContext - Shared context containing reusable data
 * @param currentSourceFile - Optional current source file for relative path resolution
 * @param typeGuardCode - Optional type guard code to analyze for additional imports
 * @returns Formatted string containing all necessary import statements
 */
const buildImportStatementsOptimized = (importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, sharedContext, currentSourceFile, typeGuardCode) => {
    // Execute the import strategy with caching
    const result = getCachedImportStrategy(`${importTypes.join(',')}-${usedEnums.join(',')}-${usedGuardzUtilities.join(',')}-${usedTypeGuards.join(',')}-${usedGuardzTypeAliases.join(',')}-${needsTypeGuardFnImport}-${typeGuardCode ? (0, type_collectors_1.needsTypeGuardFnConfig)(typeGuardCode) : false}-${typeGuardCode || ''}`, importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, sharedContext, currentSourceFile, typeGuardCode);
    // Group imports by module and build statements
    const groupedImports = groupImportsByModule(result.importItems);
    return groupedImports.join('\n');
};
exports.buildImportStatementsOptimized = buildImportStatementsOptimized;
//# sourceMappingURL=import-builders.js.map