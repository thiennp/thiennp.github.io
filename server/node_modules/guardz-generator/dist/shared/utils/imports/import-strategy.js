"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUnusedImports = exports.GUARDZ_UTILITY_NAMES = exports.executeImportStrategy = void 0;
const logging_1 = require("../logging");
const types_1 = require("../types");
const import_extractors_1 = require("./import-extractors");
// Constants
const GUARDZ_UTILITY_NAMES = [
    'isString',
    'isNumber',
    'isBoolean',
    'isDate',
    'isArrayWithEachItem',
    'isObjectWithEachItem',
    'isUndefinedOr',
    'isNullOr',
    'isNilOr',
    'isOneOf',
    'isOneOfTypes',
    'isEqualTo',
    'isAny',
    'isUnknown',
    'isDefined',
    'isNil',
    'isEnum',
    'isNonEmptyString',
    'isNonNegativeNumber',
    'isPositiveNumber',
    'isNonPositiveNumber',
    'isNegativeNumber',
    'isInteger',
    'isPositiveInteger',
    'isNegativeInteger',
    'isNonNegativeInteger',
    'isNonPositiveInteger',
    'isNumeric',
    'isBooleanLike',
    'isDateLike',
    'isBigInt',
    'isNonEmptyArray',
    'isNonEmptyArrayWithEachItem',
    'isType',
    'isPartialOf',
    'isNonNullObject',
    'isTuple',
    'isIntersectionOf',
    'isExtensionOf',
    'guardWithTolerance',
    'isAsserted',
    'isFileList',
    'isBlob',
    'isFormData',
    'isURL',
    'isURLSearchParams',
    'isObjectWith',
    'isObject',
    'isFunction',
    'isFile',
    'isMap',
    'isSet',
    'isError',
    'generateTypeGuardError',
];
exports.GUARDZ_UTILITY_NAMES = GUARDZ_UTILITY_NAMES;
// Utility functions
const extractBaseTypeName = (guardName) => {
    if (/^is[A-Z]/.test(guardName)) {
        const baseName = guardName.slice(2);
        return baseName.charAt(0).toUpperCase() + baseName.slice(1);
    }
    return guardName;
};
// Check if a type is a guardz type alias
const isGuardzTypeAlias = (typeName) => {
    const guardzTypeAliases = [
        'NonEmptyArray',
        'NonEmptyString',
        'NonNegativeNumber',
        'PositiveNumber',
        'Nullable',
        'TypeGuardFn',
        'TypeGuardFnConfig',
        'Numeric',
        'BooleanLike',
        'DateLike',
    ];
    return guardzTypeAliases.includes(typeName);
};
// Group imports by module and generate import statements
const groupImportsByModule = (imports) => {
    const quote = "'";
    const moduleGroups = new Map();
    for (const importItem of imports) {
        // Remove .ts extension from import paths
        const modulePath = importItem.path.replace(/\.ts$/, '');
        if (!moduleGroups.has(modulePath)) {
            moduleGroups.set(modulePath, {
                types: [],
                values: [],
                defaults: [],
                namespaces: [],
            });
        }
        const group = moduleGroups.get(modulePath);
        if (!group)
            continue;
        if (importItem.isDefault) {
            group.defaults.push(importItem.name);
        }
        else if (importItem.isNamespace) {
            group.namespaces.push(importItem.name);
        }
        else if (importItem.isType) {
            group.types.push(importItem.name);
        }
        else {
            group.values.push(importItem.name);
        }
    }
    const result = [];
    for (const [modulePath, group] of Array.from(moduleGroups.entries())) {
        const statements = [];
        // Add namespace imports (deduplicated)
        if (group.namespaces.length > 0) {
            const uniqueNamespaces = Array.from(new Set(group.namespaces));
            for (const namespaceName of uniqueNamespaces) {
                const statement = `import type * as ${namespaceName} from ${quote}${modulePath}${quote};`;
                statements.push(statement);
            }
        }
        // Add default imports (deduplicated)
        const uniqueDefaults = Array.from(new Set(group.defaults));
        for (const defaultName of uniqueDefaults) {
            const statement = `import type ${defaultName} from ${quote}${modulePath}${quote};`;
            statements.push(statement);
        }
        // Add type imports (deduplicated, excluding namespace names)
        const uniqueTypes = Array.from(new Set(group.types.filter(t => !group.namespaces.includes(t))));
        if (uniqueTypes.length > 0) {
            if (uniqueTypes.length === 1) {
                const statement = `import type { ${uniqueTypes[0]} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
            }
            else {
                const statement = `import type { ${uniqueTypes.join(', ')} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
            }
        }
        // Add value imports (deduplicated, excluding namespace names)
        const uniqueValues = Array.from(new Set(group.values.filter(v => !group.namespaces.includes(v))));
        if (uniqueValues.length > 0) {
            if (uniqueValues.length === 1) {
                const statement = `import { ${uniqueValues[0]} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
            }
            else {
                const statement = `import { ${uniqueValues.join(', ')} } from ${quote}${modulePath}${quote};`;
                statements.push(statement);
            }
        }
        result.push(...statements);
    }
    return result;
};
// Step 1: Copy all imports from type file (only type imports, not type guard imports)
const copyOriginalImports = (context) => {
    (0, logging_1.log)(`[copyOriginalImports] Input: context.outputDir = "${context.outputDir}", context.currentSourceFile?.fileName = "${context.currentSourceFile?.fileName}"`);
    const imports = [];
    if (!context.currentSourceFile || !context.importMap) {
        (0, logging_1.log)(`[copyOriginalImports] No currentSourceFile or importMap available`);
        return imports;
    }
    const originalImports = (0, import_extractors_1.extractImportsFromFile)(context.currentSourceFile);
    (0, logging_1.log)(`[copyOriginalImports] Found ${originalImports.length} original imports from source file`);
    for (const originalImport of originalImports) {
        (0, logging_1.log)(`[copyOriginalImports] Processing original import: ${originalImport.typeName} (${originalImport.importType}, isDefault: ${originalImport.isDefault}, isNamespace: ${originalImport.isNamespace})`);
        // Check if this is a guardz type alias
        if (isGuardzTypeAlias(originalImport.typeName)) {
            (0, logging_1.log)(`[copyOriginalImports] Guardz type alias detected: "${originalImport.typeName}", importing from 'guardz'`);
            const importItem = {
                name: originalImport.typeName,
                path: 'guardz',
                isType: true,
                isDefault: false,
                isNamespace: false,
                touchCount: 1,
            };
            (0, logging_1.log)(`[copyOriginalImports] Added guardz type alias import:`, importItem);
            imports.push(importItem);
            continue;
        }
        // For same file types, we still need to import the type guard
        if (originalImport.importType === import_extractors_1.ImportTypeEnum.FROM_SAME_FILE) {
            (0, logging_1.log)(`[copyOriginalImports] Processing same file import: ${originalImport.typeName} (will import type guard)`);
            // Continue processing to add the import
        }
        // For local imports, preserve the original import path
        // For node module imports, use the original path as is
        // Get the import path for the current source file, or use the first available path
        const resolvedPath = context.currentSourceFile &&
            originalImport.importPath[context.currentSourceFile.fileName]
            ? originalImport.importPath[context.currentSourceFile.fileName]
            : Object.values(originalImport.importPath)[0] || '';
        (0, logging_1.log)(`[copyOriginalImports] Using original import path: "${resolvedPath}"`);
        // Only add the original import (as type import), don't create type guard imports here
        const importItem = {
            name: originalImport.typeName,
            path: resolvedPath,
            isType: !originalImport.isNamespace, // Namespace imports should not be treated as type imports
            isDefault: originalImport.isDefault,
            isNamespace: originalImport.isNamespace,
            touchCount: 1,
        };
        (0, logging_1.log)(`[copyOriginalImports] Added type import:`, importItem);
        imports.push(importItem);
    }
    (0, logging_1.log)(`[copyOriginalImports] Output: ${imports.length} imports copied`);
    return imports;
};
// Step 4: Filter out guardz utilities
const filterGuardzUtilities = (typeGuards) => {
    (0, logging_1.log)(`[filterGuardzUtilities] Input: typeGuards = [${typeGuards.join(', ')}]`);
    const filtered = typeGuards.filter(guard => !GUARDZ_UTILITY_NAMES.includes(guard));
    (0, logging_1.log)(`[filterGuardzUtilities] Output: filtered = [${filtered.join(', ')}]`);
    return filtered;
};
// Step 5: Filter out enum type guards
const filterEnumTypeGuards = (typeGuards, sourceFiles) => {
    (0, logging_1.log)(`[filterEnumTypeGuards] Input: typeGuards = [${typeGuards.join(', ')}], sourceFiles.length = ${sourceFiles.length}`);
    const enumTypeGuards = new Set();
    for (const guard of typeGuards) {
        const baseTypeName = extractBaseTypeName(guard);
        (0, logging_1.log)(`[filterEnumTypeGuards] Checking guard: "${guard}" -> baseTypeName: "${baseTypeName}"`);
        // Check if the base type is an enum
        if ((0, types_1.isEnumType)(baseTypeName, sourceFiles)) {
            (0, logging_1.log)(`[filterEnumTypeGuards] ✓ "${guard}" is an enum type guard`);
            enumTypeGuards.add(guard);
        }
        else {
            (0, logging_1.log)(`[filterEnumTypeGuards] ✗ "${guard}" is not an enum type guard`);
        }
    }
    const nonEnumTypeGuards = typeGuards.filter(guard => !enumTypeGuards.has(guard));
    (0, logging_1.log)(`[filterEnumTypeGuards] Output: enumTypeGuards = [${Array.from(enumTypeGuards).join(', ')}], nonEnumTypeGuards = [${nonEnumTypeGuards.join(', ')}]`);
    return { enumTypeGuards, nonEnumTypeGuards };
};
// Step 6: Handle enum imports
const handleEnumImports = (usedEnums, enumTypeGuards, usedGuardzUtilities) => {
    const hasEnums = usedEnums.length > 0 || enumTypeGuards.size > 0;
    const updatedUtilities = [...usedGuardzUtilities];
    if (hasEnums && !updatedUtilities.includes('isEnum')) {
        updatedUtilities.push('isEnum');
    }
    return { hasEnums, updatedUtilities };
};
// Add main type imports
const addMainTypeImports = (importTypes, context, buildTypeImportInfo) => {
    const imports = [];
    for (const type of importTypes) {
        const importInfo = buildTypeImportInfo(type, context);
        if (importInfo) {
            imports.push(importInfo);
        }
    }
    return imports;
};
// Add guardz type aliases imports
const addGuardzTypeAliases = (usedGuardzTypeAliases) => {
    return usedGuardzTypeAliases.map(type => ({
        name: type,
        path: 'guardz',
        isType: true,
        isDefault: false,
    }));
};
// Add TypeGuardFn import if needed (for non-recursive types)
const addTypeGuardFnImport = (needsTypeGuardFnImport) => {
    if (!needsTypeGuardFnImport) {
        return [];
    }
    return [
        {
            name: 'TypeGuardFn',
            path: 'guardz',
            isType: true,
            isDefault: false,
        },
    ];
};
// Add TypeGuardFnConfig import if needed (for recursive types)
const addTypeGuardFnConfigImport = (needsTypeGuardFnConfigImport) => {
    if (!needsTypeGuardFnConfigImport) {
        return [];
    }
    return [
        {
            name: 'TypeGuardFnConfig',
            path: 'guardz',
            isType: true,
            isDefault: false,
        },
    ];
};
// Add guardz utilities imports
const addGuardzUtilitiesImports = (usedGuardzUtilities, hasEnums) => {
    const imports = [];
    // Add regular utilities (excluding isEnum if we're handling enums separately)
    const utilitiesToImport = usedGuardzUtilities.filter(util => !(hasEnums && util === 'isEnum'));
    if (utilitiesToImport.length > 0) {
        imports.push({
            name: utilitiesToImport.join(', '),
            path: 'guardz',
            isType: false,
            isDefault: false,
        });
    }
    // Add isEnum import separately if there are enums
    if (hasEnums) {
        imports.push({
            name: 'isEnum',
            path: 'guardz',
            isType: false,
            isDefault: false,
        });
    }
    return imports;
};
// Add remaining type guard imports
const addRemainingTypeGuardImports = (nonEnumTypeGuards, context, buildTypeGuardImportInfo) => {
    const imports = [];
    const touchCountMap = new Map();
    for (const name of nonEnumTypeGuards) {
        const importInfo = buildTypeGuardImportInfo(name, context);
        if (importInfo) {
            // Track touch count for this import
            const currentCount = touchCountMap.get(importInfo.name) || 0;
            const newCount = currentCount + 1;
            touchCountMap.set(importInfo.name, newCount);
            importInfo.touchCount = newCount;
            (0, logging_1.log)(`[addRemainingTypeGuardImports] Import "${importInfo.name}" touched ${newCount} times, path: "${importInfo.path}"`);
            imports.push(importInfo);
        }
    }
    // Log summary of touch counts
    (0, logging_1.log)(`[addRemainingTypeGuardImports] Touch count summary:`);
    for (const [name, count] of touchCountMap.entries()) {
        (0, logging_1.log)(`[addRemainingTypeGuardImports]   ${name}: ${count} touches`);
    }
    return imports;
};
// Step 7: Remove unused imports by analyzing the type guard code
const removeUnusedImports = (allImports, typeGuardCode) => {
    if (!typeGuardCode) {
        return allImports;
    }
    const usedImports = [];
    for (const importItem of allImports) {
        // Handle comma-separated imports like "TypeGuardFn, TypeGuardFnConfig"
        const importNames = importItem.name.split(',').map(name => name.trim());
        // Check if any of the imported names are used in the type guard code
        let isUsed = false;
        for (const importName of importNames) {
            // For namespace imports, check if the namespace name is used
            if (importItem.isNamespace) {
                // Check for namespace usage (e.g., "ts.CompilerOptions", "fs.WriteFileOptions")
                const namespaceUsage = new RegExp(`\\b${importName}\\.[a-zA-Z_][a-zA-Z0-9_]*\\b`).test(typeGuardCode);
                if (namespaceUsage) {
                    isUsed = true;
                    break;
                }
            }
            else {
                // For regular imports, check for direct usage
                const nameIsUsed = new RegExp(`(?:^|[^a-zA-Z0-9_])${importName}(?:[^a-zA-Z0-9_]|$)|<${importName}>`).test(typeGuardCode);
                if (nameIsUsed) {
                    isUsed = true;
                    break;
                }
            }
        }
        // Special handling for guardz utilities - always include them if they're in the list
        const isGuardzUtility = importNames.some(name => GUARDZ_UTILITY_NAMES.includes(name));
        if (isGuardzUtility || isUsed) {
            usedImports.push(importItem);
        }
    }
    return usedImports;
};
exports.removeUnusedImports = removeUnusedImports;
// Main import strategy function
const executeImportStrategy = (importTypes, usedEnums, usedGuardzUtilities, usedTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImport, needsTypeGuardFnConfigImport, context, buildTypeImportInfo, buildTypeGuardImportInfo) => {
    (0, logging_1.log)(`[executeImportStrategy] Input: importTypes = [${importTypes.join(', ')}], usedEnums = [${usedEnums.join(', ')}], usedGuardzUtilities = [${usedGuardzUtilities.join(', ')}], usedTypeGuards = [${usedTypeGuards.join(', ')}], usedGuardzTypeAliases = [${usedGuardzTypeAliases.join(', ')}], needsTypeGuardFnImport = ${needsTypeGuardFnImport}, needsTypeGuardFnConfigImport = ${needsTypeGuardFnConfigImport}, context.outputDir = "${context.outputDir}", context.currentSourceFile?.fileName = "${context.currentSourceFile?.fileName}"`);
    const allImports = [];
    // Step 1: Copy all original imports from type file (type imports only)
    (0, logging_1.log)(`[executeImportStrategy] Step 1: Copying original imports from type file`);
    const originalImportsFromFile = copyOriginalImports(context);
    (0, logging_1.log)(`[executeImportStrategy] Step 1: Added ${originalImportsFromFile.length} original imports:`, originalImportsFromFile);
    allImports.push(...originalImportsFromFile);
    // Step 2: Create type guard imports from original imports
    (0, logging_1.log)(`[executeImportStrategy] Step 2: Creating type guard imports from original imports`);
    const originalImportsFromSourceFile = context.currentSourceFile && context.importMap
        ? (0, import_extractors_1.extractImportsFromFile)(context.currentSourceFile)
        : [];
    (0, logging_1.log)(`[executeImportStrategy] Step 2: Found ${originalImportsFromSourceFile.length} original imports from source file`);
    for (const originalImport of originalImportsFromSourceFile) {
        (0, logging_1.log)(`[executeImportStrategy] Step 2: Processing original import: ${originalImport.typeName} (${originalImport.importType})`);
        if (originalImport.importType !==
            import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD &&
            originalImport.importType !==
                import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES &&
            originalImport.importType !==
                import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL) {
            const isTypeName = `is${originalImport.typeName}`;
            (0, logging_1.log)(`[executeImportStrategy] Step 2: Creating type guard import for: ${isTypeName}`);
            const importInfo = buildTypeGuardImportInfo(isTypeName, context);
            if (importInfo) {
                (0, logging_1.log)(`[executeImportStrategy] Step 2: Added type guard import:`, importInfo);
                allImports.push(importInfo);
            }
            else {
                (0, logging_1.log)(`[executeImportStrategy] Step 2: No type guard import created for: ${isTypeName}`);
            }
        }
        else {
            (0, logging_1.log)(`[executeImportStrategy] Step 2: Skipping import: ${originalImport.typeName} (${originalImport.importType})`);
        }
    }
    // Step 3: Filter out guardz utilities
    (0, logging_1.log)(`[executeImportStrategy] Step 3: Filtering out guardz utilities`);
    const filteredTypeGuards = filterGuardzUtilities(usedTypeGuards);
    (0, logging_1.log)(`[executeImportStrategy] Step 3: Filtered type guards: [${filteredTypeGuards.join(', ')}]`);
    // Step 4: Filter out enum type guards
    (0, logging_1.log)(`[executeImportStrategy] Step 4: Filtering out enum type guards`);
    const { enumTypeGuards, nonEnumTypeGuards } = filterEnumTypeGuards(filteredTypeGuards, context.sourceFiles);
    (0, logging_1.log)(`[executeImportStrategy] Step 4: Enum type guards: [${Array.from(enumTypeGuards).join(', ')}]`);
    (0, logging_1.log)(`[executeImportStrategy] Step 4: Non-enum type guards: [${nonEnumTypeGuards.join(', ')}]`);
    // Step 5: Handle enum imports
    (0, logging_1.log)(`[executeImportStrategy] Step 5: Handling enum imports`);
    const { hasEnums, updatedUtilities } = handleEnumImports(usedEnums, enumTypeGuards, usedGuardzUtilities);
    (0, logging_1.log)(`[executeImportStrategy] Step 5: hasEnums = ${hasEnums}, updatedUtilities = [${updatedUtilities.join(', ')}]`);
    // Step 6: Add main type imports (filter out types already imported by copyOriginalImports)
    (0, logging_1.log)(`[executeImportStrategy] Step 6: Adding main type imports`);
    const alreadyImportedTypes = new Set(allImports.map(importItem => importItem.name));
    (0, logging_1.log)(`[executeImportStrategy] Step 6: Already imported types: [${Array.from(alreadyImportedTypes).join(', ')}]`);
    const remainingImportTypes = importTypes.filter(type => !alreadyImportedTypes.has(type));
    (0, logging_1.log)(`[executeImportStrategy] Step 6: Remaining import types: [${remainingImportTypes.join(', ')}]`);
    const mainTypeImports = addMainTypeImports(remainingImportTypes, context, buildTypeImportInfo);
    (0, logging_1.log)(`[executeImportStrategy] Step 6: Added ${mainTypeImports.length} main type imports:`, mainTypeImports);
    allImports.push(...mainTypeImports);
    // Add guardz type aliases imports
    (0, logging_1.log)(`[executeImportStrategy] Adding guardz type aliases imports`);
    const guardzTypeAliasImports = addGuardzTypeAliases(usedGuardzTypeAliases);
    (0, logging_1.log)(`[executeImportStrategy] Added ${guardzTypeAliasImports.length} guardz type alias imports:`, guardzTypeAliasImports);
    allImports.push(...guardzTypeAliasImports);
    // Add TypeGuardFn import if needed
    (0, logging_1.log)(`[executeImportStrategy] Adding TypeGuardFn import (needed: ${needsTypeGuardFnImport})`);
    const typeGuardFnImports = addTypeGuardFnImport(needsTypeGuardFnImport);
    (0, logging_1.log)(`[executeImportStrategy] Added ${typeGuardFnImports.length} TypeGuardFn imports:`, typeGuardFnImports);
    allImports.push(...typeGuardFnImports);
    // Add TypeGuardFnConfig import if needed (for recursive types)
    (0, logging_1.log)(`[executeImportStrategy] Adding TypeGuardFnConfig import (needed: ${needsTypeGuardFnConfigImport})`);
    const typeGuardFnConfigImports = addTypeGuardFnConfigImport(needsTypeGuardFnConfigImport);
    (0, logging_1.log)(`[executeImportStrategy] Added ${typeGuardFnConfigImports.length} TypeGuardFnConfig imports:`, typeGuardFnConfigImports);
    allImports.push(...typeGuardFnConfigImports);
    // Add guardz utilities imports
    (0, logging_1.log)(`[executeImportStrategy] Adding guardz utilities imports`);
    const guardzUtilitiesImports = addGuardzUtilitiesImports(updatedUtilities, hasEnums);
    (0, logging_1.log)(`[executeImportStrategy] Added ${guardzUtilitiesImports.length} guardz utilities imports:`, guardzUtilitiesImports);
    allImports.push(...guardzUtilitiesImports);
    // Add remaining type guard imports (for types not in original imports)
    (0, logging_1.log)(`[executeImportStrategy] Adding remaining type guard imports`);
    const remainingTypeGuardImports = addRemainingTypeGuardImports(nonEnumTypeGuards, context, buildTypeGuardImportInfo);
    (0, logging_1.log)(`[executeImportStrategy] Added ${remainingTypeGuardImports.length} remaining type guard imports:`, remainingTypeGuardImports);
    allImports.push(...remainingTypeGuardImports);
    // Step 7: Remove unused imports
    (0, logging_1.log)(`[executeImportStrategy] Step 7: Removing unused imports`);
    (0, logging_1.log)(`[executeImportStrategy] Step 7: Total imports before filtering: ${allImports.length}`);
    // Temporarily disabled to fix regex error
    const filteredImports = allImports; // removeUnusedImports(allImports, typeGuardCode || '');
    (0, logging_1.log)(`[executeImportStrategy] Step 7: Total imports after filtering: ${filteredImports.length}`);
    // Step 8: Filter out imports with invalid paths
    const finalImports = filteredImports.filter(importItem => {
        return importItem.path && importItem.path.trim() !== '';
    });
    (0, logging_1.log)(`[executeImportStrategy] Step 7: Final imports with valid paths: ${finalImports.length}`);
    const result = {
        importStatements: groupImportsByModule(finalImports),
        importItems: finalImports,
    };
    (0, logging_1.log)(`[executeImportStrategy] Output: ${result.importItems.length} imports, ${result.importStatements.length} statements`);
    return result;
};
exports.executeImportStrategy = executeImportStrategy;
//# sourceMappingURL=import-strategy.js.map