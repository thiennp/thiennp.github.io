"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.findTypeGuardInProject = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
// Find an existing type guard in the project
const findTypeGuardInProject = (typeName, sourceFiles, projectRoot = process.cwd()) => {
    const guardName = `is${typeName}`;
    // First, check if there's already a generated guard file
    for (const sourceFile of sourceFiles) {
        const sourceDir = path.dirname(sourceFile.fileName);
        const potentialGuardPath = path.join(sourceDir, `${guardName}.guardz.ts`);
        if (fs.existsSync(potentialGuardPath)) {
            return { guardName, filePath: potentialGuardPath };
        }
    }
    // Search recursively in the project for the guard
    const searchForGuard = (dir) => {
        try {
            const files = fs.readdirSync(dir, { withFileTypes: true });
            for (const file of files) {
                if (file.isDirectory() &&
                    !file.name.startsWith('.') &&
                    file.name !== 'node_modules') {
                    const result = searchForGuard(path.join(dir, file.name));
                    if (result)
                        return result;
                }
                else if (file.isFile() &&
                    file.name.endsWith('.ts') &&
                    !file.name.endsWith('.guardz.ts') &&
                    !file.name.endsWith('.test.ts') &&
                    !file.name.endsWith('.spec.ts')) {
                    const filePath = path.join(dir, file.name);
                    try {
                        const content = fs.readFileSync(filePath, 'utf8');
                        // Check if the guard is exported from this file
                        // Use regex to match exact guard names to avoid substring matches
                        const guardNameRegex = new RegExp(`export\\s+(?:const|function)\\s+${guardName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b|export\\s*{\\s*[^}]*\\b${guardName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b[^}]*\\s*}`);
                        if (guardNameRegex.test(content)) {
                            return { guardName, filePath };
                        }
                    }
                    catch {
                        // Ignore file reading errors
                    }
                }
            }
        }
        catch {
            // Ignore directory reading errors
        }
        return null;
    };
    // Search in the project root and common locations
    const searchLocations = [
        projectRoot,
        path.join(projectRoot, 'src'),
        path.join(projectRoot, 'test'),
        path.join(projectRoot, 'lib'),
        path.join(projectRoot, 'utils'),
        path.join(projectRoot, 'types'),
        path.join(projectRoot, 'guards'),
    ];
    for (const searchLocation of searchLocations) {
        if (fs.existsSync(searchLocation)) {
            const result = searchForGuard(searchLocation);
            if (result)
                return result;
        }
    }
    // Check tsconfig paths if available
    try {
        const tsconfigPath = path.join(projectRoot, 'tsconfig.json');
        if (fs.existsSync(tsconfigPath)) {
            const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));
            if (tsconfig.compilerOptions?.paths) {
                for (const [, paths] of Object.entries(tsconfig.compilerOptions.paths)) {
                    if (Array.isArray(paths)) {
                        for (const mappedPath of paths) {
                            const fullPath = path.join(projectRoot, mappedPath);
                            if (fs.existsSync(fullPath)) {
                                const result = searchForGuard(fullPath);
                                if (result)
                                    return result;
                            }
                        }
                    }
                }
            }
        }
    }
    catch {
        // Ignore tsconfig parsing errors
    }
    return null;
};
exports.findTypeGuardInProject = findTypeGuardInProject;
//# sourceMappingURL=guard-finders.js.map