"use strict";
/**
 * Logging utility that can be controlled by a verbose flag
 * All logs are hidden when verbose mode is not enabled
 * Supports file logging when debug mode is enabled
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.logEmptyLines = exports.logEmptyLine = exports.logSection = exports.logDebug = exports.logWarning = exports.logError = exports.log = exports.isDebug = exports.isVerbose = exports.setDebugMode = exports.setVerboseMode = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
let isVerboseMode = false;
let isDebugMode = false;
let logFileStream = null;
/**
 * Enable or disable verbose logging mode
 * @param verbose - Whether to enable verbose logging
 */
const setVerboseMode = (verbose) => {
    isVerboseMode = verbose;
};
exports.setVerboseMode = setVerboseMode;
/**
 * Enable or disable debug logging mode (includes file logging)
 * @param debug - Whether to enable debug logging
 */
const setDebugMode = (debug) => {
    isDebugMode = debug;
    if (debug) {
        // Create log file stream
        const logFilePath = path.join(process.cwd(), 'guardz.generator.log');
        try {
            logFileStream = fs.createWriteStream(logFilePath, { flags: 'w' });
            const timestamp = new Date().toISOString();
            logFileStream.write(`=== Guardz Generator Debug Log Started at ${timestamp} ===\n`);
        }
        catch (error) {
            console.error('Failed to create log file:', error);
        }
    }
    else {
        // Close log file stream
        if (logFileStream) {
            logFileStream.end();
            logFileStream = null;
        }
    }
};
exports.setDebugMode = setDebugMode;
/**
 * Check if verbose mode is enabled
 * @returns true if verbose mode is enabled
 */
const isVerbose = () => {
    return isVerboseMode;
};
exports.isVerbose = isVerbose;
/**
 * Check if debug mode is enabled
 * @returns true if debug mode is enabled
 */
const isDebug = () => {
    return isDebugMode;
};
exports.isDebug = isDebug;
/**
 * Write a message to the log file if debug mode is enabled
 * @param message - The message to write to the log file
 */
const writeToLogFile = (message) => {
    if (isDebugMode && logFileStream) {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] ${message}\n`;
        try {
            logFileStream.write(logEntry);
        }
        catch (error) {
            console.error('Failed to write to log file:', error);
        }
    }
};
/**
 * Write a separator line to the log file if debug mode is enabled
 * @param title - Optional title for the separator
 */
const writeSeparatorToLogFile = (title) => {
    if (isDebugMode && logFileStream) {
        const timestamp = new Date().toISOString();
        const separator = title
            ? `[${timestamp}] ============== ${title} ==============\n`
            : `[${timestamp}] ==========================================\n`;
        try {
            logFileStream.write(separator);
        }
        catch (error) {
            console.error('Failed to write separator to log file:', error);
        }
    }
};
/**
 * Log a message only if verbose mode is enabled
 * @param message - The message to log
 * @param args - Additional arguments to log
 */
const log = (message, ...args) => {
    if (isVerboseMode) {
        console.log(message, ...args);
    }
    // Always write to log file if debug mode is enabled
    if (isDebugMode) {
        const fullMessage = args.length > 0
            ? `${message} ${args.map(arg => JSON.stringify(arg)).join(' ')}`
            : message;
        writeToLogFile(fullMessage);
    }
};
exports.log = log;
/**
 * Log an error message (always shown, regardless of verbose mode)
 * @param message - The error message to log
 */
const logError = (message) => {
    console.error(message);
    writeToLogFile(`ERROR: ${message}`);
};
exports.logError = logError;
/**
 * Log a warning message (always shown, regardless of verbose mode)
 * @param message - The warning message to log
 */
const logWarning = (message) => {
    console.warn(message);
    writeToLogFile(`WARNING: ${message}`);
};
exports.logWarning = logWarning;
/**
 * Log a debug message (only written to log file when debug mode is enabled)
 * @param message - The debug message to log
 * @param args - Additional arguments to log
 */
const logDebug = (message, ...args) => {
    if (isDebugMode) {
        const fullMessage = args.length > 0
            ? `${message} ${args.map(arg => JSON.stringify(arg)).join(' ')}`
            : message;
        writeToLogFile(`DEBUG: ${fullMessage}`);
    }
};
exports.logDebug = logDebug;
/**
 * Log a section separator (only written to log file when debug mode is enabled)
 * @param title - The title for the section
 */
const logSection = (title) => {
    if (isDebugMode) {
        (0, exports.logEmptyLines)(); // Add 3 empty lines before section
        writeSeparatorToLogFile(title);
    }
};
exports.logSection = logSection;
/**
 * Log an empty line (only written to log file when debug mode is enabled)
 */
const logEmptyLine = () => {
    if (isDebugMode && logFileStream) {
        try {
            logFileStream.write('\n');
        }
        catch (error) {
            console.error('Failed to write empty line to log file:', error);
        }
    }
};
exports.logEmptyLine = logEmptyLine;
/**
 * Log 3 empty lines (only written to log file when debug mode is enabled)
 */
const logEmptyLines = () => {
    if (isDebugMode && logFileStream) {
        try {
            logFileStream.write('\n\n\n');
        }
        catch (error) {
            console.error('Failed to write empty lines to log file:', error);
        }
    }
};
exports.logEmptyLines = logEmptyLines;
//# sourceMappingURL=logging.js.map