"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRecursiveOrCyclic = exports.detectCycles = exports.getAllReferencedTypes = exports.buildTypeDependendencyGraph = exports.isRecursiveType = void 0;
exports.typeReferencesInterface = typeReferencesInterface;
const ts = __importStar(require("typescript"));
const property_extractors_1 = require("./property-extractors");
// Check if a type references a specific interface
function typeReferencesInterface(typeNode, interfaceName) {
    if (ts.isTypeReferenceNode(typeNode)) {
        const typeName = typeNode.typeName.getText();
        if (typeName === interfaceName) {
            return true;
        }
        // Check type arguments for recursion
        if (typeNode.typeArguments) {
            return typeNode.typeArguments.some(arg => typeReferencesInterface(arg, interfaceName));
        }
    }
    else if (ts.isArrayTypeNode(typeNode)) {
        return typeReferencesInterface(typeNode.elementType, interfaceName);
    }
    else if (ts.isUnionTypeNode(typeNode)) {
        return typeNode.types.some(type => typeReferencesInterface(type, interfaceName));
    }
    else if (ts.isIntersectionTypeNode(typeNode)) {
        return typeNode.types.some(type => typeReferencesInterface(type, interfaceName));
    }
    else if (ts.isParenthesizedTypeNode(typeNode)) {
        return typeReferencesInterface(typeNode.type, interfaceName);
    }
    else if (ts.isTypeLiteralNode(typeNode)) {
        return typeNode.members.some(member => {
            if (ts.isPropertySignature(member) && member.type) {
                return typeReferencesInterface(member.type, interfaceName);
            }
            return false;
        });
    }
    else if (ts.isOptionalTypeNode(typeNode)) {
        return typeReferencesInterface(typeNode.type, interfaceName);
    }
    return false;
}
// Check if an interface is directly recursive
const isRecursiveType = (interfaceDecl) => {
    const interfaceName = interfaceDecl.name.text;
    const properties = (0, property_extractors_1.extractProperties)(interfaceDecl);
    // Check properties for direct recursion
    const hasRecursiveProperty = properties.some(property => typeReferencesInterface(property.type, interfaceName));
    // Also check heritage clauses for recursion
    if (interfaceDecl.heritageClauses) {
        const hasRecursiveHeritage = interfaceDecl.heritageClauses.some(clause => clause.types.some(type => typeReferencesInterface(type, interfaceName)));
        if (hasRecursiveHeritage) {
            return true;
        }
    }
    return hasRecursiveProperty;
};
exports.isRecursiveType = isRecursiveType;
// Build a dependency graph for interfaces
const buildTypeDependendencyGraph = (interfaces) => {
    const graph = new Map();
    // Initialize graph with all interface names
    interfaces.forEach(interfaceDecl => {
        const name = interfaceDecl.name.text;
        graph.set(name, new Set());
    });
    // Build dependencies
    interfaces.forEach(interfaceDecl => {
        const interfaceName = interfaceDecl.name.text;
        const dependencies = graph.get(interfaceName) ?? new Set();
        graph.set(interfaceName, dependencies);
        // Get all referenced types in this interface
        const referencedTypes = (0, exports.getAllReferencedTypes)(interfaceDecl);
        // Add dependencies that are also interfaces in our graph
        referencedTypes.forEach(typeName => {
            if (graph.has(typeName)) {
                dependencies.add(typeName);
            }
        });
        // Also check heritage clauses
        if (interfaceDecl.heritageClauses) {
            interfaceDecl.heritageClauses.forEach(clause => {
                clause.types.forEach(type => {
                    const baseTypeName = type.expression.getText();
                    if (graph.has(baseTypeName)) {
                        dependencies.add(baseTypeName);
                    }
                });
            });
        }
    });
    return graph;
};
exports.buildTypeDependendencyGraph = buildTypeDependendencyGraph;
// Get all referenced types from an interface
const getAllReferencedTypes = (interfaceDecl) => {
    const referencedTypes = new Set();
    const visitTypeNode = (typeNode) => {
        if (ts.isTypeReferenceNode(typeNode)) {
            const typeName = typeNode.typeName.getText();
            referencedTypes.add(typeName);
            // Also visit type arguments
            if (typeNode.typeArguments) {
                typeNode.typeArguments.forEach(visitTypeNode);
            }
        }
        else if (ts.isArrayTypeNode(typeNode)) {
            visitTypeNode(typeNode.elementType);
        }
        else if (ts.isUnionTypeNode(typeNode)) {
            typeNode.types.forEach(visitTypeNode);
        }
        else if (ts.isParenthesizedTypeNode(typeNode)) {
            visitTypeNode(typeNode.type);
        }
        else if (ts.isTypeLiteralNode(typeNode)) {
            typeNode.members.forEach(member => {
                if (ts.isPropertySignature(member) && member.type) {
                    visitTypeNode(member.type);
                }
            });
        }
    };
    // Visit all properties
    interfaceDecl.members.forEach(member => {
        if (ts.isPropertySignature(member) && member.type) {
            visitTypeNode(member.type);
        }
    });
    return referencedTypes;
};
exports.getAllReferencedTypes = getAllReferencedTypes;
// Detect cycles in a dependency graph
const detectCycles = (graph) => {
    const visited = new Set();
    const recursionStack = new Set();
    const cyclicTypes = new Set();
    const dfs = (node) => {
        if (recursionStack.has(node)) {
            // We found a cycle, mark all nodes in the current path as cyclic
            cyclicTypes.add(node);
            return true;
        }
        if (visited.has(node)) {
            return false;
        }
        visited.add(node);
        recursionStack.add(node);
        const dependencies = graph.get(node);
        if (dependencies) {
            dependencies.forEach(dependency => {
                if (dfs(dependency)) {
                    cyclicTypes.add(node);
                    // Continue to mark all nodes in the cycle
                }
            });
        }
        recursionStack.delete(node);
        return false;
    };
    // Check all nodes
    graph.forEach((_, node) => {
        if (!visited.has(node)) {
            dfs(node);
        }
    });
    return cyclicTypes;
};
exports.detectCycles = detectCycles;
// Check if an interface is recursive or cyclic
const isRecursiveOrCyclic = (interfaceDecl) => {
    // First check for direct recursion (existing logic)
    if ((0, exports.isRecursiveType)(interfaceDecl)) {
        return true;
    }
    // For type guard generation, we only need to detect direct recursion
    // Indirect cycles (like Course -> Section -> Module -> Course) don't require
    // the recursive function signature with TypeGuardFnConfig
    return false;
};
exports.isRecursiveOrCyclic = isRecursiveOrCyclic;
//# sourceMappingURL=recursion-detection.js.map