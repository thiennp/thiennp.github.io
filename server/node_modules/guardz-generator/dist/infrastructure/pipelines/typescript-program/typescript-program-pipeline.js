"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptProgramPipeline = void 0;
const service_factory_1 = require("../../factories/service-factory");
const cli_program_strategy_1 = require("./strategies/cli-strategy/cli-program-strategy");
const default_program_strategy_1 = require("./strategies/default-strategy/default-program-strategy");
const tsconfig_program_strategy_1 = require("./strategies/tsconfig-strategy/tsconfig-program-strategy");
/**
 * TypeScript Program Creation Pipeline
 *
 * Orchestrates multiple TypeScript program creation strategies to create TypeScript programs
 * for type guard generation. Strategies are executed in priority order: CLI → tsconfig → default,
 * with later strategies being used as fallbacks if earlier strategies fail.
 */
class TypeScriptProgramPipeline {
    cliStrategy;
    tsConfigStrategy;
    defaultStrategy;
    constructor() {
        this.cliStrategy = new cli_program_strategy_1.CliProgramStrategy();
        this.tsConfigStrategy = new tsconfig_program_strategy_1.TsConfigProgramStrategy();
        this.defaultStrategy = new default_program_strategy_1.DefaultProgramStrategy();
    }
    /**
     * Create a TypeScript program using the best available strategy
     * @param options Program creation options
     * @returns Promise resolving to created program result
     */
    async createProgram(options) {
        let lastError = null;
        // Try CLI strategy first (highest priority)
        if (await this.cliStrategy.canCreateProgram(options)) {
            try {
                return await this.cliStrategy.createProgram(options);
            }
            catch (error) {
                lastError = error;
            }
        }
        // Try tsconfig strategy second (medium priority)
        if (await this.tsConfigStrategy.canCreateProgram(options)) {
            try {
                return await this.tsConfigStrategy.createProgram(options);
            }
            catch (error) {
                lastError = error;
            }
        }
        // Use default strategy as fallback (lowest priority)
        if (await this.defaultStrategy.canCreateProgram(options)) {
            try {
                return await this.defaultStrategy.createProgram(options);
            }
            catch (error) {
                lastError = error;
            }
        }
        // If we have a last error, throw it with context
        if (lastError) {
            throw new Error(`All program creation strategies failed. Last error: ${lastError.message}`);
        }
        throw new Error('No program creation strategy can handle the provided options');
    }
    /**
     * Check if any strategy can create a program
     * @param options Configuration options for program creation
     * @returns Promise resolving to true if any strategy can create a program
     */
    async canCreateProgram(options) {
        // Check CLI strategy
        if (await this.cliStrategy.canCreateProgram(options)) {
            return true;
        }
        // Check tsconfig strategy
        if (await this.tsConfigStrategy.canCreateProgram(options)) {
            return true;
        }
        // Check default strategy
        if (await this.defaultStrategy.canCreateProgram(options)) {
            return true;
        }
        return false;
    }
    /**
     * Get detailed information about each strategy's capabilities
     * @param options Configuration options for program creation
     * @returns Promise resolving to strategy information
     */
    async getStrategyInfo(options) {
        const cliCanCreate = await this.cliStrategy.canCreateProgram(options);
        const tsConfigCanCreate = await this.tsConfigStrategy.canCreateProgram(options);
        const defaultCanCreate = await this.defaultStrategy.canCreateProgram(options);
        const result = {
            cli: { canCreate: cliCanCreate },
            tsconfig: { canCreate: tsConfigCanCreate },
            default: { canCreate: defaultCanCreate },
        };
        // Optionally include compiler options for debugging
        if (process.env.NODE_ENV === 'development' || process.env.DEBUG) {
            try {
                if (cliCanCreate) {
                    const cliResult = await this.cliStrategy.createProgram(options);
                    result.cli.options = cliResult.compilerOptions;
                }
                if (tsConfigCanCreate) {
                    const tsConfigResult = await this.tsConfigStrategy.createProgram(options);
                    result.tsconfig.options = tsConfigResult.compilerOptions;
                }
                if (defaultCanCreate) {
                    const defaultResult = await this.defaultStrategy.createProgram(options);
                    result.default.options = defaultResult.compilerOptions;
                }
            }
            catch {
                // Ignore errors in debug mode
            }
        }
        return result;
    }
    /**
     * Get the strategy instances for advanced usage
     * @returns Object containing all strategy instances
     */
    getStrategies() {
        return {
            cli: this.cliStrategy,
            tsconfig: this.tsConfigStrategy,
            default: this.defaultStrategy,
        };
    }
    /**
     * Format generated files using Prettier, TypeScript checking, and ESLint
     * @param filePaths Array of file paths to format
     * @param options Formatting options
     * @returns Promise that resolves when formatting is complete
     */
    async formatGeneratedFiles(filePaths, options) {
        if (filePaths.length === 0) {
            return;
        }
        const { typeCheck = true, eslintFix = true } = options || {};
        try {
            // Get services from factory
            const prettier = service_factory_1.ServiceFactory.getPrettier();
            const typescriptCompiler = service_factory_1.ServiceFactory.getTypeScriptCompiler();
            const eslint = service_factory_1.ServiceFactory.getESLint();
            const logger = service_factory_1.ServiceFactory.getLogger();
            logger.log('Starting formatting of generated files...');
            // Format with Prettier
            try {
                // Read and format each file individually since Prettier interface only supports single file formatting
                for (const filePath of filePaths) {
                    const fileSystem = service_factory_1.ServiceFactory.getFileSystem();
                    const content = await fileSystem.readFile(filePath);
                    // Check if the file contains generic type parameters
                    const hasGenericTypeParams = content.includes('= <') ||
                        content.includes('function ') ||
                        (content.includes('export const') &&
                            content.includes('<') &&
                            content.includes('>'));
                    // Get the Prettier config for the file
                    const prettierConfig = await prettier.resolveConfig(filePath);
                    // Use different trailing comma settings based on whether file has generic type parameters
                    const formatOptions = {
                        ...prettierConfig,
                        parser: 'typescript',
                        trailingComma: hasGenericTypeParams
                            ? 'none'
                            : prettierConfig?.trailingComma || 'none',
                    };
                    const formattedContent = await prettier.format(content, formatOptions);
                    // Post-process to remove trailing commas from generic type parameters
                    let finalContent = formattedContent;
                    if (hasGenericTypeParams) {
                        // Remove trailing commas from generic type parameters like <T,> -> <T>
                        finalContent = formattedContent.replace(/<([^>]+),>/g, '<$1>');
                    }
                    await fileSystem.writeFile(filePath, finalContent);
                }
                logger.log('✓ Prettier formatting applied to generated files');
            }
            catch (error) {
                logger.warn('⚠ Prettier formatting failed:', error.message);
            }
            // TypeScript type checking
            if (typeCheck) {
                try {
                    await typescriptCompiler.checkFiles(filePaths);
                    logger.log('✓ TypeScript type checking passed for generated files');
                }
                catch (error) {
                    logger.warn('⚠ TypeScript type checking failed:', error.message);
                }
            }
            // ESLint fixes
            if (eslintFix) {
                try {
                    await eslint.fixFiles(filePaths);
                    logger.log('✓ ESLint fixes applied to generated files');
                }
                catch (error) {
                    logger.warn('⚠ ESLint fixes failed:', error.message);
                }
            }
            logger.log('✓ Formatting of generated files completed');
        }
        catch (error) {
            const logger = service_factory_1.ServiceFactory.getLogger();
            logger.error('Formatting of generated files failed:', error.message);
            throw error;
        }
    }
}
exports.TypeScriptProgramPipeline = TypeScriptProgramPipeline;
//# sourceMappingURL=typescript-program-pipeline.js.map