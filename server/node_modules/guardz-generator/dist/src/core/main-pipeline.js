"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.mainPipeline = mainPipeline;
const typeCollectionPipeline_1 = require("../application/2-type-collection-pipeline/typeCollectionPipeline");
const fromCli_1 = require("../application/2-type-collection-pipeline/strategies/fromCli/fromCli");
const fromConfig_1 = require("../application/2-type-collection-pipeline/strategies/fromConfig/fromConfig");
const fromSourceFiles_1 = require("../application/2-type-collection-pipeline/strategies/fromSourceFiles/fromSourceFiles");
const typeGuardGenerationPipeline_1 = require("../application/3-type-guard-generation-pipeline/typeGuardGenerationPipeline");
const fromInterface_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromInterface/fromInterface");
const fromTypeAlias_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromTypeAlias/fromTypeAlias");
const fromUnionType_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromUnionType/fromUnionType");
const fromIntersectionType_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromIntersectionType/fromIntersectionType");
const fromArrayType_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromArrayType/fromArrayType");
const fromGenericInterface_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromGenericInterface/fromGenericInterface");
const fromGenericTypeAlias_1 = require("../application/3-type-guard-generation-pipeline/strategies/fromGenericTypeAlias/fromGenericTypeAlias");
const importDetectionPipeline_1 = require("../application/4-import-detection-pipeline/importDetectionPipeline");
const outputPipeline_1 = require("../application/5-output-pipeline/outputPipeline");
const writeToFile_1 = require("../application/5-output-pipeline/strategies/writeToFile");
const printSummary_1 = require("../application/5-output-pipeline/strategies/printSummary");
const discoverFilesPipeline_1 = require("../application/1-files-discovery-pipeline/discoverFilesPipeline");
const fromCli_2 = require("../application/1-files-discovery-pipeline/strategies/fromCli/fromCli");
const fromConfigFile_1 = require("../application/1-files-discovery-pipeline/strategies/fromConfigFile/fromConfigFile");
const takeAll_1 = require("../application/1-files-discovery-pipeline/strategies/takeAll/takeAll");
const logger_1 = require("../utils/logger");
const ts = __importStar(require("typescript"));
const fs = __importStar(require("fs"));
async function mainPipeline({ filesGlob, types, nodeModulesDir = 'node_modules', searchDirs = ['src/guards', 'src/generated'], globalAliases = {}, }) {
    logger_1.logger.step('MAIN_PIPELINE', 'Starting main pipeline execution');
    logger_1.logger.info(`Input files: ${filesGlob?.length || 0} files`);
    logger_1.logger.info(`Types specified: ${types?.length || 0} types`);
    // 1. Files discovery
    logger_1.logger.step('FILE_DISCOVERY', 'Starting file discovery');
    const filesToProcess = await (0, discoverFilesPipeline_1.discoverFilesPipeline)([fromCli_2.fromCli, fromConfigFile_1.fromConfigFile, takeAll_1.takeAll], {
        includes: filesGlob,
        excludes: [],
    });
    if (!filesToProcess || filesToProcess.length === 0) {
        logger_1.logger.error('No files found');
        throw new Error('No files found');
    }
    logger_1.logger.step('FILE_DISCOVERY', `Found ${filesToProcess.length} files to process`);
    logger_1.logger.result('FILE_DISCOVERY', { files: filesToProcess });
    // 2. Type collection
    logger_1.logger.step('TYPE_COLLECTION', 'Starting type collection from source files');
    const sourceFiles = filesToProcess.map((filePath) => ts.createSourceFile(filePath, fs.readFileSync(filePath, 'utf-8'), ts.ScriptTarget.Latest, true));
    logger_1.logger.info(`Created ${sourceFiles.length} source files`);
    const typeCollectionContext = {
        sourceFiles,
        cliTypes: types,
        configTypes: [],
    };
    const typeResult = await (0, typeCollectionPipeline_1.typeCollectionPipeline)([
        ctx => (0, fromCli_1.fromCli)(ctx),
        ctx => (0, fromConfig_1.fromConfig)(ctx),
        ctx => (0, fromSourceFiles_1.fromSourceFiles)(ctx),
    ], typeCollectionContext);
    if (!typeResult ||
        (!typeResult.interfaces.length && !typeResult.typeAliases.length)) {
        logger_1.logger.error('No types/interfaces found');
        throw new Error('No types/interfaces found');
    }
    logger_1.logger.step('TYPE_COLLECTION', `Found ${typeResult.interfaces.length} interfaces and ${typeResult.typeAliases.length} type aliases`);
    logger_1.logger.result('TYPE_COLLECTION', {
        interfaces: typeResult.interfaces.map(i => i.name.text),
        typeAliases: typeResult.typeAliases.map(t => t.name.text),
    });
    const typesToProcess = [
        ...typeResult.interfaces
            .filter((node) => filesToProcess.includes(node.getSourceFile().fileName))
            .map((node) => ({
            typeName: node.name.text,
            node,
            fileName: node.getSourceFile().fileName,
        })),
        ...typeResult.typeAliases
            .filter((node) => filesToProcess.includes(node.getSourceFile().fileName))
            .map((node) => ({
            typeName: node.name.text,
            node,
            fileName: node.getSourceFile().fileName,
        })),
    ];
    logger_1.logger.step('TYPE_FILTERING', `Filtered to ${typesToProcess.length} types to process`);
    logger_1.logger.result('TYPE_FILTERING', {
        typesToProcess: typesToProcess.map(t => `${t.typeName} (${t.fileName})`),
    });
    // Debug: print types to process
    console.log('Types to process:', typesToProcess.map(t => `${t.typeName} (${t.fileName})`));
    // 3. Type guard generation
    logger_1.logger.step('TYPE_GUARD_GENERATION', 'Starting type guard generation');
    const typeGuardGenerationContext = {
        typesToProcess,
    };
    const guards = await (0, typeGuardGenerationPipeline_1.typeGuardGenerationPipeline)([
        ctx => (0, fromInterface_1.fromInterface)(ctx),
        ctx => (0, fromTypeAlias_1.fromTypeAlias)(ctx),
        ctx => (0, fromUnionType_1.fromUnionType)(ctx),
        ctx => (0, fromIntersectionType_1.fromIntersectionType)(ctx),
        ctx => (0, fromArrayType_1.fromArrayType)(ctx),
        ctx => (0, fromGenericInterface_1.fromGenericInterface)(ctx),
        ctx => (0, fromGenericTypeAlias_1.fromGenericTypeAlias)(ctx),
    ], typeGuardGenerationContext);
    logger_1.logger.step('TYPE_GUARD_GENERATION', `Generated ${guards.length} type guards`);
    logger_1.logger.result('TYPE_GUARD_GENERATION', {
        generatedGuards: guards.map(g => g.typeName),
        totalGuards: guards.length,
    });
    // 4. Import detection
    logger_1.logger.step('IMPORT_DETECTION', 'Starting import detection');
    const importDetectionContext = {
        nodeModulesDir: nodeModulesDir || 'node_modules',
        searchDirs: searchDirs || ['src/guards', 'src/generated'],
        globalAliases: globalAliases || {},
        currentDir: process.cwd(),
    };
    await (0, importDetectionPipeline_1.importDetectionPipeline)(typesToProcess, importDetectionContext);
    logger_1.logger.step('IMPORT_DETECTION', 'Import detection completed');
    // 5. Output pipeline - Write generated type guards to files
    logger_1.logger.step('OUTPUT_PIPELINE', 'Starting output pipeline');
    const filesToWrite = guards.map(guard => {
        // Find the original type info to get the source file path
        const originalType = typesToProcess.find(t => t.typeName === guard.typeName);
        const sourceFile = originalType?.fileName || '';
        const sourceDir = sourceFile.substring(0, sourceFile.lastIndexOf('/'));
        return {
            fileName: `is${guard.typeName}.guardz.ts`,
            content: guard.code,
            outputDir: sourceDir || '.',
        };
    });
    await (0, outputPipeline_1.outputPipeline)([ctx => (0, writeToFile_1.writeToFile)(ctx), ctx => (0, printSummary_1.printSummary)(ctx)], filesToWrite, {});
    logger_1.logger.step('OUTPUT_PIPELINE', `Wrote ${filesToWrite.length} type guard files`);
    logger_1.logger.result('OUTPUT_PIPELINE', {
        filesWritten: filesToWrite.map(f => f.fileName),
        totalFiles: filesToWrite.length,
    });
    logger_1.logger.step('MAIN_PIPELINE', 'Main pipeline completed successfully');
    logger_1.logger.result('MAIN_PIPELINE', {
        totalFilesProcessed: filesToProcess.length,
        totalTypesProcessed: typesToProcess.length,
        totalGuardsGenerated: guards.length,
    });
    return guards;
}
//# sourceMappingURL=main-pipeline.js.map