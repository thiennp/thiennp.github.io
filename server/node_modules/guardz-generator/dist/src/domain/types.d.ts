import * as ts from 'typescript';
export interface TypeGuardOptions {
    interfaceName?: string;
    guardName?: string;
    generateSeparateFiles?: boolean;
    type?: string;
    includes?: string[];
    excludes?: string[];
    quoteType?: 'single' | 'double';
    postProcess?: boolean;
    output?: string;
}
export interface GeneratedFile {
    fileName: string;
    content: string;
    interfaceName: string;
}
export interface TypeParameter {
    name: string;
    constraint?: ts.TypeNode;
    default?: ts.TypeNode;
}
export interface PropertyInfo {
    name: string;
    type: ts.TypeNode;
    isOptional: boolean;
}
export interface TypeGuardContext {
    typeParameterNames?: string[];
    isGeneric?: boolean;
    sourceFiles?: ts.SourceFile[];
    importMap?: Map<string, ImportInfo>;
}
export declare enum ImportType {
    NODE_MODULE_WITH_GUARD_FROM_NODE_MODULE = "NODE_MODULE_WITH_GUARD_FROM_NODE_MODULE",
    NODE_MODULE_WITH_GUARD_FROM_PROJECT = "NODE_MODULE_WITH_GUARD_FROM_PROJECT",
    NODE_MODULE_NO_GUARD = "NODE_MODULE_NO_GUARD",
    GLOBAL_PATH = "GLOBAL_PATH",
    RELATIVE_PATH = "RELATIVE_PATH"
}
export interface ImportInfo {
    typeName: string;
    importPath: string;
    isDefault: boolean;
    isFromNodeModule: boolean;
    importType?: ImportType;
    guardSource?: 'node_modules' | 'project' | null;
}
export interface GuardzUtility {
    name: string;
    pattern: RegExp;
}
export interface TypeGuardFunction {
    name: string;
    sourceFile: string;
}
export type TypeNodeHandler = (typeNode: ts.TypeNode, context: TypeGuardContext) => string;
export type PropertyGuardGenerator = (property: PropertyInfo, context: TypeGuardContext) => string;
//# sourceMappingURL=types.d.ts.map