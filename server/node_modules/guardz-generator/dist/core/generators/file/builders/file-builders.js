"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCompleteFile = void 0;
const imports_1 = require("../../../../shared/utils/imports");
const logging_1 = require("../../../../shared/utils/logging");
const buildCompleteFile = (guardName, typeGuardCode, interfaceName, importTypes, fileName, outputDir, sourceFiles, needsTypeGuardFnImport, importMap, currentSourceFile, sharedContext) => {
    // Collect enums used in the generated type guard code
    const usedEnumsInCode = (0, imports_1.collectUsedEnumsInCode)(typeGuardCode);
    // Collect guardz utilities used in the generated code
    const usedGuardzUtilities = (0, imports_1.collectUsedGuardzUtilities)(typeGuardCode);
    // Collect type guard functions used in the generated code
    const usedTypeGuards = (0, imports_1.collectUsedTypeGuards)(typeGuardCode);
    // Filter out self-reference to prevent circular imports
    const filteredTypeGuards = usedTypeGuards.filter(name => name !== guardName);
    // Only import types that are actually referenced in the generated code
    const usedTypes = importTypes.filter(type => {
        // Check for direct type usage (like in generic parameters)
        const directUsage = new RegExp(`\\b${type}\\b`).test(typeGuardCode);
        // Check for type guard function usage (like isPrimitiveTypes)
        const typeGuardUsage = new RegExp(`\\bis${type}\\b`).test(typeGuardCode);
        // Check for types used in generic parameters (like Category in isOneOfTypes<Category | number>)
        const genericUsage = new RegExp(`<[^>]*\\b${type}\\b[^>]*>`).test(typeGuardCode);
        return directUsage || typeGuardUsage || genericUsage;
    });
    // Detect additional types used in the generated code that might not be in importTypes
    const additionalTypes = new Set();
    // Look for types used in generic parameters (like Category in isOneOfTypes<Category | number>)
    const genericTypePattern = /<([^>]+)>/g;
    let match;
    while ((match = genericTypePattern.exec(typeGuardCode)) !== null) {
        const genericContent = match[1];
        // Extract type names from the generic content (split by |, &, etc.)
        const typeNames = genericContent
            .split(/[|&]/)
            .map(type => type.trim())
            .filter(type => /^[A-Z][a-zA-Z0-9_]*$/.test(type)); // Only valid type names
        typeNames.forEach(typeName => {
            if (!usedTypes.includes(typeName) && !importTypes.includes(typeName)) {
                additionalTypes.add(typeName);
            }
        });
    }
    // Add additional types to usedTypes
    const finalUsedTypes = [...usedTypes, ...Array.from(additionalTypes)];
    // Always include the interface name being generated
    if (!finalUsedTypes.includes(interfaceName)) {
        finalUsedTypes.push(interfaceName);
    }
    // Also add any types that are used in the generated code but not in importTypes
    const allTypesUsedInCode = new Set();
    // Check for direct type usage in the generated code
    const directTypePattern = /\b([A-Z][a-zA-Z0-9_]*)\b/g;
    let typeMatch;
    while ((typeMatch = directTypePattern.exec(typeGuardCode)) !== null) {
        const typeName = typeMatch[1];
        // Skip common keywords and utilities
        if (![
            'isType',
            'isUndefinedOr',
            'isNullOr',
            'isArrayWithEachItem',
            'isOneOfTypes',
            'isNumber',
            'isString',
            'isEqualTo',
            'isUnknown',
            'isOneOf',
            'TypeGuardFn',
        ].includes(typeName)) {
            allTypesUsedInCode.add(typeName);
        }
    }
    // Add any missing types to finalUsedTypes
    allTypesUsedInCode.forEach(typeName => {
        if (!finalUsedTypes.includes(typeName) && !importTypes.includes(typeName)) {
            finalUsedTypes.push(typeName);
        }
    });
    // Collect guardz type aliases used in the generated code
    const usedGuardzTypeAliases = (0, imports_1.collectUsedGuardzTypeAliases)(typeGuardCode);
    // Check if TypeGuardFn import is needed
    const needsTypeGuardFnImportFinal = needsTypeGuardFnImport || (0, imports_1.needsTypeGuardFn)(typeGuardCode);
    // Use optimized version if shared context is provided
    const useOptimized = !!sharedContext;
    (0, logging_1.logSection)('File Generation');
    (0, logging_1.logDebug)('Building import statements', {
        useOptimized,
        finalUsedTypesCount: finalUsedTypes.length,
        usedEnumsInCodeCount: usedEnumsInCode.length,
        usedGuardzUtilitiesCount: usedGuardzUtilities.length,
        filteredTypeGuardsCount: filteredTypeGuards.length,
        usedGuardzTypeAliasesCount: usedGuardzTypeAliases.length,
        needsTypeGuardFnImportFinal,
        outputDir,
    });
    const importsSection = useOptimized
        ? (0, imports_1.buildImportStatementsOptimized)(finalUsedTypes, usedEnumsInCode, usedGuardzUtilities, filteredTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImportFinal, {
            ...sharedContext,
            outputDir,
        }, currentSourceFile, typeGuardCode)
        : (0, imports_1.buildImportStatements)(finalUsedTypes, usedEnumsInCode, usedGuardzUtilities, filteredTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImportFinal, outputDir, sourceFiles, importMap, currentSourceFile, typeGuardCode);
    // Remove unused imports from the generated content
    const cleanedContent = (0, imports_1.removeUnusedImports)(typeGuardCode);
    return {
        content: `${importsSection}\n\n${cleanedContent}`,
        usedTypes: finalUsedTypes,
        usedEnums: usedEnumsInCode,
        usedGuardzUtilities,
        usedTypeGuards: filteredTypeGuards,
        usedGuardzTypeAliases,
    };
};
exports.buildCompleteFile = buildCompleteFile;
//# sourceMappingURL=file-builders.js.map