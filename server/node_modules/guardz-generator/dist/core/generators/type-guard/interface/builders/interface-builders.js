"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildInterfaceTypeGuard = exports.buildStandardGuard = exports.buildRecursiveGuard = exports.buildInheritanceGuard = exports.buildIndexSignatureGuard = void 0;
const property_extractors_1 = require("../../../../../shared/utils/ast/property-extractors");
const type_support_1 = require("../../../../../shared/utils/type-support");
const convert_type_to_guard_1 = require("../../handlers/convert-type-to-guard");
const generate_property_guard_1 = require("./generate-property-guard");
const buildIndexSignatureGuard = (guardName, indexSignatureType, keyType, context) => {
    const valueTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(indexSignatureType, context);
    const keyTypeGuard = keyType
        ? (0, convert_type_to_guard_1.convertTypeToGuard)(keyType, context)
        : 'isString';
    return `export const ${guardName} = isIndexSignature(${keyTypeGuard}, ${valueTypeGuard});`;
};
exports.buildIndexSignatureGuard = buildIndexSignatureGuard;
const buildInheritanceGuard = (guardName, interfaceDecl, heritageTypes, currentPropertyGuards) => {
    if (currentPropertyGuards) {
        return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isExtensionOf(is${heritageTypes[0]}, isType<Omit<${interfaceDecl.name.text}, keyof ${heritageTypes[0]}>>({ ${currentPropertyGuards} }));`;
    }
    else {
        // If no new properties, just extend the base
        return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = is${heritageTypes[0]};`;
    }
};
exports.buildInheritanceGuard = buildInheritanceGuard;
const buildRecursiveGuard = (guardName, interfaceDecl, propertyGuards) => {
    return `export function ${guardName}(value: unknown, config?: TypeGuardFnConfig | null): value is ${interfaceDecl.name.text} {\n  return isType<${interfaceDecl.name.text}>({ ${propertyGuards} })(value, config);\n}`;
};
exports.buildRecursiveGuard = buildRecursiveGuard;
const buildStandardGuard = (guardName, interfaceDecl, propertyGuards) => {
    return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuards} });`;
};
exports.buildStandardGuard = buildStandardGuard;
const buildInterfaceTypeGuard = (interfaceDecl, guardName, collectionResult, allInterfaces, sourceFiles, importMap, currentSourceFile) => {
    const context = { sourceFiles, importMap, currentSourceFile };
    // Handle index signatures
    if (collectionResult.hasOnlyIndexSignatures &&
        collectionResult.indexSignatureType) {
        return (0, exports.buildIndexSignatureGuard)(guardName, collectionResult.indexSignatureType, collectionResult.indexSignatureKeyType, context);
    }
    // Handle recursive interfaces FIRST (before inheritance)
    if (collectionResult.isRecursive) {
        const propertyGuards = collectionResult.properties
            .map(prop => (0, generate_property_guard_1.generatePropertyGuard)(prop, context))
            .join(', ');
        return (0, exports.buildRecursiveGuard)(guardName, interfaceDecl, propertyGuards);
    }
    // Handle inheritance
    if (collectionResult.hasInheritance && allInterfaces) {
        // Get the base interface
        const baseInterface = allInterfaces.find(int => int.name.text === collectionResult.heritageTypes[0]);
        if (baseInterface) {
            // Get ALL properties from the base interface (including inherited ones)
            const baseProperties = (0, property_extractors_1.extractPropertiesWithInheritance)(baseInterface, allInterfaces);
            const basePropertyNames = baseProperties.map(p => p.name);
            // Get only the properties that are NOT in the base interface
            const currentProperties = collectionResult.properties.filter(prop => !basePropertyNames.includes(prop.name));
            const currentPropertyGuards = currentProperties
                .map(prop => (0, generate_property_guard_1.generatePropertyGuard)(prop, context))
                .join(', ');
            return (0, exports.buildInheritanceGuard)(guardName, interfaceDecl, collectionResult.heritageTypes, currentPropertyGuards);
        }
    }
    // Handle regular properties
    const propertyGuards = collectionResult.properties.map(prop => ({
        ...prop,
        typeGuard: (0, generate_property_guard_1.generatePropertyGuard)(prop, context),
    }));
    // Separate properties into supported and unsupported based on their type guards
    const supported = propertyGuards.filter(p => (0, type_support_1.isSupportedTypeGuard)(p.typeGuard));
    const unsupported = propertyGuards.filter(p => !(0, type_support_1.isSupportedTypeGuard)(p.typeGuard));
    // If all properties are supported, use the standard approach
    if (unsupported.length === 0) {
        const propertyGuardsString = propertyGuards
            .map(prop => prop.typeGuard)
            .join(', ');
        return (0, exports.buildStandardGuard)(guardName, interfaceDecl, propertyGuardsString);
    }
    // If all properties are unsupported, use the actual generated type guards
    if (supported.length === 0) {
        const propertyGuardsString = propertyGuards
            .map(prop => prop.typeGuard)
            .join(', ');
        return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuardsString} });`;
    }
    // Mixed case: use isType with proper guards for supported and actual type guards for unsupported
    const allPropertyGuards = propertyGuards.map(prop => {
        if ((0, type_support_1.isSupportedTypeGuard)(prop.typeGuard)) {
            return prop.typeGuard;
        }
        else {
            return prop.typeGuard;
        }
    });
    const propertyGuardsString = allPropertyGuards.join(', ');
    return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuardsString} });`;
};
exports.buildInterfaceTypeGuard = buildInterfaceTypeGuard;
//# sourceMappingURL=interface-builders.js.map