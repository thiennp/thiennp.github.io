"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectCurrentProperties = exports.collectInheritedProperties = exports.collectInterfaceProperties = void 0;
const ast_1 = require("../../../../../shared/utils/ast");
const collectInterfaceProperties = (interfaceDecl, allInterfaces) => {
    // Check if this interface has only index signatures
    const hasOnlyIndexSigs = (0, ast_1.hasOnlyIndexSignatures)(interfaceDecl);
    const indexSignatureType = hasOnlyIndexSigs
        ? (0, ast_1.extractIndexSignatureType)(interfaceDecl) || undefined
        : undefined;
    const { keyType, valueType } = hasOnlyIndexSigs
        ? (0, ast_1.extractIndexSignatureTypes)(interfaceDecl)
        : { keyType: undefined, valueType: undefined };
    const indexSignatureKeyType = keyType || undefined;
    const indexSignatureValueType = valueType || undefined;
    const heritageTypes = (0, ast_1.extractHeritageClauses)(interfaceDecl);
    const hasInheritance = heritageTypes.length > 0;
    // Use the new recursion detection if we have all interfaces, otherwise fall back to the old method
    const isRecursive = allInterfaces
        ? (0, ast_1.isRecursiveOrCyclic)(interfaceDecl)
        : (0, ast_1.isRecursiveType)(interfaceDecl);
    // Extract properties based on inheritance
    const properties = allInterfaces
        ? (0, ast_1.extractPropertiesWithInheritance)(interfaceDecl, allInterfaces)
        : (0, ast_1.extractProperties)(interfaceDecl);
    return {
        properties,
        isRecursive,
        hasInheritance,
        heritageTypes,
        hasOnlyIndexSignatures: hasOnlyIndexSigs,
        indexSignatureType,
        indexSignatureKeyType,
        indexSignatureValueType,
    };
};
exports.collectInterfaceProperties = collectInterfaceProperties;
const collectInheritedProperties = (interfaceDecl, allInterfaces, heritageTypes) => {
    if (heritageTypes.length === 0)
        return [];
    const baseInterface = allInterfaces.find(int => int.name.text === heritageTypes[0]);
    if (!baseInterface)
        return [];
    // Get all inherited property names
    return (0, ast_1.extractPropertiesWithInheritance)(baseInterface, allInterfaces);
};
exports.collectInheritedProperties = collectInheritedProperties;
const collectCurrentProperties = (interfaceDecl, inheritedProps) => {
    const inheritedPropNames = inheritedProps.map(p => p.name);
    // Get only the properties that are not inherited (current interface properties)
    return (0, ast_1.extractProperties)(interfaceDecl).filter(prop => !inheritedPropNames.includes(prop.name));
};
exports.collectCurrentProperties = collectCurrentProperties;
//# sourceMappingURL=property-collectors.js.map