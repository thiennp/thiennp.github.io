"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInterfaceTypeGuard = void 0;
const ast_1 = require("../../../../../shared/utils/ast");
const type_support_1 = require("../../../../../shared/utils/type-support");
const convert_type_to_guard_1 = require("../../handlers/convert-type-to-guard");
const generate_property_guard_1 = require("./generate-property-guard");
const generateInterfaceTypeGuard = (interfaceDecl, guardName, allInterfaces, sourceFiles, importMap, currentSourceFile) => {
    // Check if this interface has only index signatures
    if ((0, ast_1.hasOnlyIndexSignatures)(interfaceDecl)) {
        const { keyType, valueType } = (0, ast_1.extractIndexSignatureTypes)(interfaceDecl);
        if (valueType) {
            const context = { sourceFiles, importMap, currentSourceFile };
            const valueTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(valueType, context);
            const keyTypeGuard = keyType
                ? (0, convert_type_to_guard_1.convertTypeToGuard)(keyType, context)
                : 'isString';
            return `export const ${guardName} = isIndexSignature(${keyTypeGuard}, ${valueTypeGuard});`;
        }
    }
    const heritageTypes = (0, ast_1.extractHeritageClauses)(interfaceDecl);
    const hasInheritance = heritageTypes.length > 0;
    // Use the new recursion detection if we have all interfaces, otherwise fall back to the old method
    const isRecursive = allInterfaces
        ? (0, ast_1.isRecursiveOrCyclic)(interfaceDecl)
        : (0, ast_1.isRecursiveType)(interfaceDecl);
    const context = { sourceFiles, importMap, currentSourceFile };
    if (hasInheritance && allInterfaces) {
        // Handle inheritance using isExtensionOf
        const baseInterface = allInterfaces.find(int => int.name.text === heritageTypes[0]);
        if (baseInterface) {
            // Get all inherited property names
            const inheritedProps = (0, ast_1.extractPropertiesWithInheritance)(baseInterface, allInterfaces).map(p => p.name);
            // Get only the properties that are not inherited (current interface properties)
            const currentProperties = (0, ast_1.extractProperties)(interfaceDecl).filter(prop => !inheritedProps.includes(prop.name));
            const currentPropertyGuards = currentProperties
                .map(prop => (0, generate_property_guard_1.generatePropertyGuard)(prop, context))
                .join(', ');
            if (currentPropertyGuards) {
                return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isExtensionOf(is${heritageTypes[0]}, isType<${interfaceDecl.name.text}>({ ${currentPropertyGuards} }));`;
            }
            else {
                // If no new properties, just extend the base
                return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = is${heritageTypes[0]};`;
            }
        }
    }
    // Fall back to regular property extraction (includes inherited properties)
    const properties = allInterfaces
        ? (0, ast_1.extractPropertiesWithInheritance)(interfaceDecl, allInterfaces)
        : (0, ast_1.extractProperties)(interfaceDecl);
    // Generate type guards for all properties first
    const propertyGuards = properties.map(prop => ({
        ...prop,
        typeGuard: (0, generate_property_guard_1.generatePropertyGuard)(prop, context),
    }));
    // Separate properties into supported and unsupported based on their type guards
    const supported = propertyGuards.filter(p => (0, type_support_1.isSupportedTypeGuard)(p.typeGuard));
    const unsupported = propertyGuards.filter(p => !(0, type_support_1.isSupportedTypeGuard)(p.typeGuard));
    // If all properties are supported, use the original approach
    if (unsupported.length === 0) {
        const propertyGuardsString = propertyGuards
            .map(prop => prop.typeGuard)
            .join(', ');
        if (isRecursive) {
            return `export function ${guardName}(value: unknown, config?: TypeGuardFnConfig | null): value is ${interfaceDecl.name.text} {\n  return isType<${interfaceDecl.name.text}>({ ${propertyGuardsString} })(value, config);\n}`;
        }
        else {
            return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuardsString} });`;
        }
    }
    // If all properties are unsupported, use individual isAsserted for each property
    if (supported.length === 0) {
        const propertyGuardsString = propertyGuards
            .map(prop => prop.typeGuard)
            .join(', ');
        return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isType<${interfaceDecl.name.text}>({ ${propertyGuardsString} });`;
    }
    // Mixed case: create intersection of supported and unsupported
    const supportedPropertyGuardsString = supported
        .map(prop => prop.typeGuard)
        .join(', ');
    const supportedPropertyNames = supported
        .map(prop => `'${prop.name}'`)
        .join(', ');
    const supportedTypeGuard = `isType<Pick<${interfaceDecl.name.text}, ${supportedPropertyNames}>>({ ${supportedPropertyGuardsString} })`;
    const unsupportedTypeGuard = `isAsserted<Omit<${interfaceDecl.name.text}, ${supportedPropertyNames}>>(value => true)`;
    return `export const ${guardName}: TypeGuardFn<${interfaceDecl.name.text}> = isIntersectionOf(${supportedTypeGuard}, ${unsupportedTypeGuard});`;
};
exports.generateInterfaceTypeGuard = generateInterfaceTypeGuard;
//# sourceMappingURL=generate-interface-type-guard.js.map