"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTypeReference = void 0;
const ts = __importStar(require("typescript"));
const ast_1 = require("../../../../shared/utils/ast");
const imports_1 = require("../../../../shared/utils/imports");
const import_extractors_1 = require("../../../../shared/utils/imports/import-extractors");
const types_1 = require("../../../../shared/utils/types");
const convert_type_to_guard_1 = require("./convert-type-to-guard");
const handle_type_literal_1 = require("./handle-type-literal");
// Helper function to extract keys from a type node (union of string literals)
const extractKeysFromTypeNode = (keys) => {
    if (ts.isUnionTypeNode(keys)) {
        return keys.types.map(type => {
            if (ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal)) {
                return type.literal.text;
            }
            return type.getText().replace(/['"]/g, '');
        });
    }
    else if (ts.isLiteralTypeNode(keys) && ts.isStringLiteral(keys.literal)) {
        return [keys.literal.text];
    }
    return [];
};
// Helper function to extract picked properties from a type literal
const extractPickedProperties = (sourceType, keys) => {
    const pickedKeys = extractKeysFromTypeNode(keys);
    const properties = [];
    sourceType.members.forEach(member => {
        if (ts.isPropertySignature(member)) {
            const propertyName = member.name.getText();
            if (pickedKeys.includes(propertyName) && member.type) {
                const propertyType = (0, convert_type_to_guard_1.convertTypeToGuard)(member.type, {});
                properties.push(`${propertyName}: ${propertyType}`);
            }
        }
    });
    return `{ ${properties.join(', ')} }`;
};
// Helper function to extract omitted properties from a type literal
const extractOmittedProperties = (sourceType, keys) => {
    const omittedKeys = extractKeysFromTypeNode(keys);
    const properties = [];
    sourceType.members.forEach(member => {
        if (ts.isPropertySignature(member)) {
            const propertyName = member.name.getText();
            if (!omittedKeys.includes(propertyName) && member.type) {
                const propertyType = (0, convert_type_to_guard_1.convertTypeToGuard)(member.type, {});
                properties.push(`${propertyName}: ${propertyType}`);
            }
        }
    });
    return `{ ${properties.join(', ')} }`;
};
// Helper function to convert a type to a required version (remove optional wrappers)
const convertToRequiredTypeGuard = (typeNode, context) => {
    if (ts.isTypeLiteralNode(typeNode)) {
        // For type literals, we need to handle each property and remove optional wrappers
        const properties = typeNode.members
            .map((member) => {
            if (ts.isIndexSignatureDeclaration(member)) {
                return '';
            }
            if (ts.isPropertySignature(member) && member.name && member.type) {
                const name = member.name.getText();
                // Always treat as required (remove optional wrappers)
                const typeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(member.type, context);
                return `${name}: ${typeGuard}`;
            }
            return '';
        })
            .filter(Boolean);
        return `{ ${properties.join(', ')} }`;
    }
    else {
        // For non-type-literals, just convert normally
        return (0, convert_type_to_guard_1.convertTypeToGuard)(typeNode, context);
    }
};
// Helper function to find a type definition in the current file
const findTypeDefinitionInFile = (typeName, sourceFile) => {
    let found = null;
    const visit = (node) => {
        if (found)
            return;
        if (ts.isInterfaceDeclaration(node) && node.name.text === typeName) {
            found = node;
        }
        else if (ts.isTypeAliasDeclaration(node) && node.name.text === typeName) {
            found = node;
        }
        else {
            ts.forEachChild(node, visit);
        }
    };
    visit(sourceFile);
    return found;
};
// Helper function to generate an inline type guard for a type definition
const generateInlineTypeGuard = (typeDefinition, context) => {
    if (ts.isInterfaceDeclaration(typeDefinition)) {
        // For interfaces, generate the type guard inline
        const properties = [];
        typeDefinition.members.forEach(member => {
            if (ts.isPropertySignature(member) && member.name && member.type) {
                const propertyName = member.name.getText();
                const propertyType = (0, convert_type_to_guard_1.convertTypeToGuard)(member.type, context);
                properties.push(`${propertyName}: ${propertyType}`);
            }
        });
        const typeText = typeDefinition.getText();
        return `isType<${typeText}>(${properties.length > 0 ? `{ ${properties.join(', ')} }` : '{}'})`;
    }
    else if (ts.isTypeAliasDeclaration(typeDefinition)) {
        // For type aliases, convert the type directly
        const typeText = typeDefinition.getText();
        const typeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(typeDefinition.type, context);
        return `isType<${typeText}>(${typeGuard})`;
    }
    // This should never happen since we only call this with InterfaceDeclaration or TypeAliasDeclaration
    return 'isAsserted<unknown>';
};
// Helper function to find type definition and get default type parameters
const findTypeDefinitionWithDefaults = (typeName, sourceFiles, currentSourceFile) => {
    // First check in current source file
    if (currentSourceFile) {
        const typeDefinition = findTypeDefinitionInFile(typeName, currentSourceFile);
        if (typeDefinition) {
            if (ts.isInterfaceDeclaration(typeDefinition)) {
                const typeParameters = (0, ast_1.extractTypeParametersFromInterface)(typeDefinition);
                const hasDefaults = typeParameters.some(tp => tp.default);
                return { typeParameters, hasDefaults };
            }
            else if (ts.isTypeAliasDeclaration(typeDefinition)) {
                const typeParameters = (0, ast_1.extractTypeParameters)(typeDefinition);
                const hasDefaults = typeParameters.some(tp => tp.default);
                return { typeParameters, hasDefaults };
            }
        }
    }
    // Then check in all source files
    if (sourceFiles) {
        for (const sourceFile of sourceFiles) {
            const typeDefinition = findTypeDefinitionInFile(typeName, sourceFile);
            if (typeDefinition) {
                if (ts.isInterfaceDeclaration(typeDefinition)) {
                    const typeParameters = (0, ast_1.extractTypeParametersFromInterface)(typeDefinition);
                    const hasDefaults = typeParameters.some(tp => tp.default);
                    return { typeParameters, hasDefaults };
                }
                else if (ts.isTypeAliasDeclaration(typeDefinition)) {
                    const typeParameters = (0, ast_1.extractTypeParameters)(typeDefinition);
                    const hasDefaults = typeParameters.some(tp => tp.default);
                    return { typeParameters, hasDefaults };
                }
            }
        }
    }
    return null;
};
// Helper function to generate type guard with default type parameters
const generateTypeGuardWithDefaults = (typeName, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
typeParameters, context) => {
    const defaultTypeArgs = [];
    for (const typeParam of typeParameters) {
        if (typeParam.default) {
            const defaultTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(typeParam.default, context);
            defaultTypeArgs.push(defaultTypeGuard);
        }
        else {
            // If no default, use isUnknown as fallback
            defaultTypeArgs.push('isUnknown');
        }
    }
    if (defaultTypeArgs.length === 1) {
        // Single type parameter case
        const defaultArg = defaultTypeArgs[0];
        return `is${typeName}<${typeParameters[0].default?.getText() || 'unknown'}>(${defaultArg})`;
    }
    else {
        // Multiple type parameters case
        const typeArgTexts = typeParameters.map(tp => tp.default?.getText() || 'unknown');
        const typeArgsString = typeArgTexts.join(', ');
        const guardArgsString = defaultTypeArgs.join(', ');
        return `is${typeName}<${typeArgsString}>(${guardArgsString})`;
    }
};
const handleTypeReference = (typeNode, context) => {
    if (!ts.isTypeReferenceNode(typeNode)) {
        throw new Error('Expected TypeReferenceNode');
    }
    const typeName = typeNode.typeName.getText();
    // Check if this is a generic type parameter
    if (context.typeParameterNames?.includes(typeName)) {
        return `typeGuard${typeName}`;
    }
    // Check if this is an enum type
    if (context.sourceFiles && (0, types_1.isEnumType)(typeName, context.sourceFiles)) {
        return `isEnum(${typeName})`;
    }
    // Check if this type is imported from an npm package or is a native type
    if (context.importMap) {
        const importInfo = context.importMap.get(typeName);
        if (importInfo) {
            // For native types, check if they have guardz support first
            if (importInfo.importType === import_extractors_1.ImportTypeEnum.FROM_NATIVE) {
                // Check if this native type has a guardz equivalent
                const guardzSupportedTypes = [
                    'string',
                    'number',
                    'boolean',
                    'Date',
                    'Array',
                    'array',
                    'object',
                    'Function',
                    'File',
                    'Map',
                    'Set',
                    'Error',
                    'FileList',
                    'Blob',
                    'FormData',
                    'URL',
                    'URLSearchParams',
                ];
                if (guardzSupportedTypes.includes(typeName)) {
                    // Let it fall through to the switch statement for proper handling
                }
                else {
                    // For unsupported native types, use isAsserted
                    return `isAsserted<${typeName}>`;
                }
            }
            // For node modules
            if (importInfo.importType ===
                import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITHOUT_TYPE_GUARD ||
                importInfo.importType ===
                    import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_NODE_MODULES ||
                importInfo.importType ===
                    import_extractors_1.ImportTypeEnum.FROM_NODE_MODULES_WITH_TYPE_GUARD_FROM_GLOBAL) {
                // Check if this is a guardz type - if so, handle it normally
                if ((0, imports_1.isGuardzType)(typeName)) {
                    // For guardz types, use the normal switch case logic below
                }
                else {
                    // For non-guardz npm package types, first try to find an existing guard in the project
                    if (context.sourceFiles) {
                        const existingGuard = (0, types_1.findTypeGuardInProject)(typeName, context.sourceFiles);
                        if (existingGuard) {
                            return existingGuard.guardName;
                        }
                    }
                    // If no guard found, use isAsserted<TypeName>
                    return `isAsserted<${typeName}>`;
                }
            }
        }
    }
    switch (typeName) {
        case 'string':
            return 'isString';
        case 'number':
            return 'isNumber';
        case 'boolean':
            return 'isBoolean';
        case 'Date':
            return 'isDate';
        case 'Array':
        case 'array':
        case 'ReadonlyArray':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const elementType = (0, convert_type_to_guard_1.convertTypeToGuard)(typeNode.typeArguments[0], context);
                return `isArrayWithEachItem(${elementType})`;
            }
            return 'isArrayWithEachItem(isUnknown)';
        case 'Nullable':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const innerType = (0, convert_type_to_guard_1.convertTypeToGuard)(typeNode.typeArguments[0], context);
                return `isNullOr(${innerType})`;
            }
            return 'isNullOr(isUnknown)';
        case 'Record':
            if (typeNode.typeArguments && typeNode.typeArguments.length >= 2) {
                const valueType = (0, convert_type_to_guard_1.convertTypeToGuard)(typeNode.typeArguments[1], context);
                return `isObjectWithEachItem(${valueType})`;
            }
            return 'isObjectWithEachItem(isUnknown)';
        case 'NonEmptyString':
            return 'isNonEmptyString';
        case 'NonNegativeNumber':
            return 'isNonNegativeNumber';
        case 'PositiveNumber':
            return 'isPositiveNumber';
        case 'NonPositiveNumber':
            return 'isNonPositiveNumber';
        case 'NegativeNumber':
            return 'isNegativeNumber';
        case 'Integer':
            return 'isInteger';
        case 'PositiveInteger':
            return 'isPositiveInteger';
        case 'NegativeInteger':
            return 'isNegativeInteger';
        case 'NonNegativeInteger':
            return 'isNonNegativeInteger';
        case 'NonPositiveInteger':
            return 'isNonPositiveInteger';
        case 'Numeric':
            return 'isNumeric';
        case 'BooleanLike':
            return 'isBooleanLike';
        case 'DateLike':
            return 'isDateLike';
        case 'NonEmptyArray':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const elementType = (0, convert_type_to_guard_1.convertTypeToGuard)(typeNode.typeArguments[0], context);
                return `isNonEmptyArrayWithEachItem(${elementType})`;
            }
            return 'isNonEmptyArrayWithEachItem(isUnknown)';
        case 'Partial':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const arg = typeNode.typeArguments[0];
                let innerTypeGuard;
                if (ts.isTypeLiteralNode(arg)) {
                    innerTypeGuard = (0, handle_type_literal_1.handleTypeLiteral)(arg, context, false);
                }
                else {
                    innerTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(arg, context);
                }
                return `isPartialOf<${arg.getText()}>(${innerTypeGuard})`;
            }
            return 'isPartialOf(isUnknown)';
        case 'Required':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const arg = typeNode.typeArguments[0];
                const innerTypeGuard = convertToRequiredTypeGuard(arg, context);
                return `isType<Required<${arg.getText()}>>(${innerTypeGuard})`;
            }
            return 'isType<Required<unknown>>({})';
        case 'Readonly':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                const arg = typeNode.typeArguments[0];
                let innerTypeGuard;
                if (ts.isTypeLiteralNode(arg)) {
                    innerTypeGuard = (0, handle_type_literal_1.handleTypeLiteral)(arg, context, false);
                }
                else {
                    innerTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(arg, context);
                }
                return `isType<Readonly<${arg.getText()}>>(${innerTypeGuard})`;
            }
            return 'isType<Readonly<unknown>>({})';
        case 'Pick':
            if (typeNode.typeArguments && typeNode.typeArguments.length >= 2) {
                const sourceType = typeNode.typeArguments[0];
                const keys = typeNode.typeArguments[1];
                // For Pick, we need to create a type guard that only includes the picked properties
                if (ts.isTypeLiteralNode(sourceType)) {
                    const pickedProperties = extractPickedProperties(sourceType, keys);
                    return `isType<Pick<${sourceType.getText()}, ${keys.getText()}>>(${pickedProperties})`;
                }
                else {
                    // For non-type literal source types, use the full type guard
                    const innerTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(sourceType, context);
                    return `isType<Pick<${sourceType.getText()}, ${keys.getText()}>>(${innerTypeGuard})`;
                }
            }
            return 'isType<Pick<unknown, never>>({})';
        case 'Omit':
            if (typeNode.typeArguments && typeNode.typeArguments.length >= 2) {
                const sourceType = typeNode.typeArguments[0];
                const keys = typeNode.typeArguments[1];
                // For Omit, we need to create a type guard that excludes the omitted properties
                if (ts.isTypeLiteralNode(sourceType)) {
                    const omittedProperties = extractOmittedProperties(sourceType, keys);
                    return `isType<Omit<${sourceType.getText()}, ${keys.getText()}>>(${omittedProperties})`;
                }
                else {
                    // For non-type literal source types, use the full type guard
                    const innerTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(sourceType, context);
                    return `isType<Omit<${sourceType.getText()}, ${keys.getText()}>>(${innerTypeGuard})`;
                }
            }
            return 'isType<Omit<unknown, never>>({})';
        case 'object':
            return 'isObject';
        case 'Function':
            return 'isFunction';
        case 'File':
            return 'isFile';
        case 'Map':
            if (typeNode.typeArguments && typeNode.typeArguments.length >= 2) {
                // For Map with specific types, use isAsserted since guardz isMap doesn't validate contents
                return `isAsserted<${typeNode.getText()}>`;
            }
            return 'isMap';
        case 'Set':
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                // For Set with specific types, use isAsserted since guardz isSet doesn't validate contents
                return `isAsserted<${typeNode.getText()}>`;
            }
            return 'isSet';
        case 'Error':
            return 'isError';
        case 'FileList':
            return 'isFileList';
        case 'Blob':
            return 'isBlob';
        case 'FormData':
            return 'isFormData';
        case 'URL':
            return 'isURL';
        case 'URLSearchParams':
            return 'isURLSearchParams';
        case 'Branded':
            if (typeNode.typeArguments && typeNode.typeArguments.length >= 2) {
                const baseType = typeNode.typeArguments[0];
                const baseTypeGuard = (0, convert_type_to_guard_1.convertTypeToGuard)(baseType, context);
                const brandedTypeText = typeNode.getText();
                return `isBranded<${brandedTypeText}>(${baseTypeGuard})`;
            }
            return 'isBranded<unknown>(isUnknown)';
        default:
            // Check if this is an interface that has a corresponding type guard
            if (context.isGeneric && context.typeParameterNames?.includes(typeName)) {
                return `typeGuard${typeName}`;
            }
            // Check if this is a generic type guard function with type arguments
            if (typeNode.typeArguments && typeNode.typeArguments.length > 0) {
                // Check if the type argument is a specific literal type
                const typeArg = typeNode.typeArguments[0];
                if (ts.isLiteralTypeNode(typeArg)) {
                    const literalValue = typeArg.literal.getText();
                    return `is${typeName}<${literalValue}>(${literalValue === 'true' ? 'isEqualTo(true)' : 'isEqualTo(false)'})`;
                }
                // For other specific types, use the type argument directly
                const typeArgText = typeArg.getText();
                return `is${typeName}<${typeArgText}>(${(0, convert_type_to_guard_1.convertTypeToGuard)(typeArg, context)})`;
            }
            // Check if this type has no type arguments but has default type parameters
            if (!typeNode.typeArguments || typeNode.typeArguments.length === 0) {
                const typeDefinition = findTypeDefinitionWithDefaults(typeName, context.sourceFiles, context.currentSourceFile);
                if (typeDefinition && typeDefinition.hasDefaults) {
                    return generateTypeGuardWithDefaults(typeName, typeDefinition.typeParameters, context);
                }
            }
            // Check if this type has an import strategy
            if (context.importMap && context.importMap.has(typeName)) {
                const importInfo = context.importMap.get(typeName);
                if (importInfo) {
                    // For same file types, use the type guard function
                    if (importInfo.importType === import_extractors_1.ImportTypeEnum.FROM_SAME_FILE) {
                        return `is${typeName}`;
                    }
                    // For other import types, use the type guard function
                    return `is${typeName}`;
                }
            }
            // Check if there's an existing type guard for this type in the project
            if (context.sourceFiles) {
                const existingGuard = (0, types_1.findTypeGuardInProject)(typeName, context.sourceFiles);
                if (existingGuard) {
                    return existingGuard.guardName;
                }
            }
            // Check if this type is defined in the current file but not exported
            if (context.currentSourceFile) {
                const typeDefinition = findTypeDefinitionInFile(typeName, context.currentSourceFile);
                if (typeDefinition) {
                    // Generate the type guard inline by copying the type definition
                    return generateInlineTypeGuard(typeDefinition, context);
                }
            }
            // For types that don't fall into any import strategy, use isAsserted
            return `isAsserted<${typeName}>`;
    }
};
exports.handleTypeReference = handleTypeReference;
//# sourceMappingURL=handle-type-reference.js.map