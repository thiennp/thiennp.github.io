"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleUnionType = void 0;
const ts = __importStar(require("typescript"));
const convert_type_to_guard_1 = require("./convert-type-to-guard");
const handle_type_reference_1 = require("./handle-type-reference");
const handleUnionType = (typeNode, context) => {
    if (!ts.isUnionTypeNode(typeNode)) {
        throw new Error('Expected UnionTypeNode');
    }
    const types = typeNode.types;
    const typeText = typeNode.getText();
    if (types.length === 2) {
        if (typeText === 'string | null') {
            return 'isNullOr(isString)';
        }
        if (typeText === 'string | undefined') {
            return 'isUndefinedOr(isString)';
        }
        if (typeText === 'number | undefined') {
            return 'isUndefinedOr(isNumber)';
        }
        if (typeText === 'boolean | undefined') {
            return 'isUndefinedOr(isBoolean)';
        }
        if (typeText === 'Date | undefined') {
            return 'isUndefinedOr(isDate)';
        }
    }
    // Check for null | undefined combinations
    const hasNull = types.some(type => ts.isLiteralTypeNode(type) &&
        type.literal.kind === ts.SyntaxKind.NullKeyword);
    const hasUndefined = types.some(type => ts.isLiteralTypeNode(type) &&
        type.literal.kind === ts.SyntaxKind.UndefinedKeyword);
    if (hasNull && hasUndefined && types.length === 3) {
        // Handle pattern like string | null | undefined
        const nonNullTypes = types.filter(type => !(ts.isLiteralTypeNode(type) &&
            (type.literal.kind === ts.SyntaxKind.NullKeyword ||
                type.literal.kind === ts.SyntaxKind.UndefinedKeyword)));
        if (nonNullTypes.length === 1) {
            const innerType = (0, convert_type_to_guard_1.convertTypeToGuard)(nonNullTypes[0], context);
            return `isNilOr(${innerType})`;
        }
    }
    // Check if all types are literal types
    const allLiterals = types.every((type) => ts.isLiteralTypeNode(type) &&
        (type.literal.kind === ts.SyntaxKind.StringLiteral ||
            type.literal.kind === ts.SyntaxKind.NumericLiteral ||
            type.literal.kind === ts.SyntaxKind.BooleanKeyword));
    if (allLiterals) {
        // Extract both the literal text and the raw value for sorting
        const literalPairs = types
            .map((type) => {
            if (ts.isLiteralTypeNode(type)) {
                // For sorting, use the string value for strings, number for numbers, boolean for booleans
                let sortValue = type.literal.getText();
                let typeString = type.literal.getText();
                if (ts.isStringLiteral(type.literal)) {
                    sortValue = type.literal.text;
                    typeString = `'${type.literal.text}'`;
                }
                else if (ts.isNumericLiteral(type.literal)) {
                    sortValue = Number(type.literal.text);
                    typeString = type.literal.text;
                }
                else if (type.literal.kind === ts.SyntaxKind.TrueKeyword) {
                    sortValue = true;
                    typeString = 'true';
                }
                else if (type.literal.kind === ts.SyntaxKind.FalseKeyword) {
                    sortValue = false;
                    typeString = 'false';
                }
                return { sortValue, typeString };
            }
            return null;
        })
            .filter(Boolean);
        // Sort by stringified value for consistency
        literalPairs.sort((a, b) => {
            if (typeof a.sortValue === 'number' && typeof b.sortValue === 'number') {
                return a.sortValue - b.sortValue;
            }
            return String(a.sortValue).localeCompare(String(b.sortValue));
        });
        const genericType = literalPairs.map(p => p.typeString).join(' | ');
        const argList = literalPairs.map(p => p.typeString).join(', ');
        return `isOneOf<${genericType}>(${argList})`;
    }
    // Check for union with null or undefined
    if (hasNull && types.length === 2) {
        const nonNullType = types.find(type => !(ts.isLiteralTypeNode(type) &&
            type.literal.kind === ts.SyntaxKind.NullKeyword));
        if (nonNullType) {
            const innerType = (0, convert_type_to_guard_1.convertTypeToGuard)(nonNullType, context);
            return `isNullOr(${innerType})`;
        }
    }
    // Handle case where we have multiple string literals plus null
    if (hasNull && types.length > 2) {
        const nonNullTypes = types.filter(type => !(ts.isLiteralTypeNode(type) &&
            type.literal.kind === ts.SyntaxKind.NullKeyword));
        // Check if all non-null types are string literals
        const allStringLiterals = nonNullTypes.every((type) => ts.isLiteralTypeNode(type) &&
            type.literal.kind === ts.SyntaxKind.StringLiteral);
        if (allStringLiterals) {
            const literalPairs = nonNullTypes
                .map((type) => {
                if (ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal)) {
                    return {
                        sortValue: type.literal.text,
                        typeString: `'${type.literal.text}'`,
                    };
                }
                return null;
            })
                .filter(Boolean);
            literalPairs.sort((a, b) => a.sortValue.localeCompare(b.sortValue));
            const genericType = literalPairs.map(p => p.typeString).join(' | ');
            const argList = literalPairs.map(p => p.typeString).join(', ');
            return `isNullOr(isOneOf<${genericType}>(${argList}))`;
        }
    }
    if (hasUndefined && types.length === 2) {
        const nonUndefinedType = types.find(type => !(ts.isLiteralTypeNode(type) &&
            type.literal.kind === ts.SyntaxKind.UndefinedKeyword));
        if (nonUndefinedType) {
            const innerType = (0, convert_type_to_guard_1.convertTypeToGuard)(nonUndefinedType, context);
            return `isUndefinedOr(${innerType})`;
        }
    }
    // For type unions like string | number | boolean, use isOneOfTypes
    const typePairs = types.map((type) => {
        let actualType = type;
        if (ts.isParenthesizedTypeNode(actualType)) {
            actualType = actualType.type;
        }
        const typeName = actualType.getText();
        let guard;
        if (ts.isTypeReferenceNode(actualType)) {
            if (context.typeParameterNames?.includes(typeName)) {
                guard = `typeGuard${typeName}`;
            }
            else {
                guard = (0, handle_type_reference_1.handleTypeReference)(actualType, context);
            }
        }
        else {
            guard = (0, convert_type_to_guard_1.convertTypeToGuard)(actualType, context);
        }
        return { typeName, guard };
    });
    typePairs.sort((a, b) => a.typeName.localeCompare(b.typeName));
    const genericType = typePairs.map(pair => pair.typeName).join(' | ');
    const guardArgs = typePairs.map(pair => pair.guard).join(', ');
    return `isOneOfTypes<${genericType}>(${guardArgs})`;
};
exports.handleUnionType = handleUnionType;
//# sourceMappingURL=handle-union-type.js.map