"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCompleteFile = void 0;
const imports_1 = require("../../../shared/utils/imports");
const generateCompleteFile = (guardName, typeGuardCode, interfaceName, importTypes, fileName, outputDir, sourceFiles, needsTypeGuardFnImport, importMap, currentSourceFile) => {
    // Strip out any import statements from the typeGuardCode
    const lines = typeGuardCode.split('\n');
    const nonImportLines = lines.filter(line => {
        const trimmed = line.trim();
        return (!trimmed.startsWith('import ') &&
            !trimmed.startsWith('import type ') &&
            trimmed !== '');
    });
    const cleanTypeGuardCode = nonImportLines.join('\n');
    // Collect enums used in the generated type guard code
    const usedEnumsInCode = (0, imports_1.collectUsedEnumsInCode)(cleanTypeGuardCode);
    // Collect guardz utilities used in the generated code
    const usedGuardzUtilities = (0, imports_1.collectUsedGuardzUtilities)(cleanTypeGuardCode);
    // Collect type guard functions used in the generated code
    const usedTypeGuards = (0, imports_1.collectUsedTypeGuards)(cleanTypeGuardCode);
    // Filter out self-reference to prevent circular imports
    const filteredTypeGuards = usedTypeGuards.filter(name => name !== guardName);
    // Only import types that are actually referenced in the generated code
    const usedTypes = importTypes.filter(type => {
        // Check for direct type usage (like in generic parameters)
        const directUsage = new RegExp(`\\b${type}\\b`).test(cleanTypeGuardCode);
        // Check for type guard function usage (like isPrimitiveTypes)
        const typeGuardUsage = new RegExp(`\\bis${type}\\b`).test(cleanTypeGuardCode);
        return directUsage || typeGuardUsage;
    });
    // Always include the interface name being generated
    if (!usedTypes.includes(interfaceName)) {
        usedTypes.push(interfaceName);
    }
    // Collect guardz type aliases used in the generated code
    const usedGuardzTypeAliases = (0, imports_1.collectUsedGuardzTypeAliases)(cleanTypeGuardCode);
    // Check if TypeGuardFn import is needed
    const needsTypeGuardFnImportFinal = needsTypeGuardFnImport || (0, imports_1.needsTypeGuardFn)(cleanTypeGuardCode);
    const importsSection = (0, imports_1.buildImportStatements)(usedTypes, usedEnumsInCode, usedGuardzUtilities, filteredTypeGuards, usedGuardzTypeAliases, needsTypeGuardFnImportFinal, outputDir, sourceFiles, importMap, currentSourceFile, cleanTypeGuardCode);
    const rawContent = `${importsSection}\n\n${cleanTypeGuardCode}\n`;
    // Remove unused imports from the generated content
    return (0, imports_1.removeUnusedImports)(rawContent);
};
exports.generateCompleteFile = generateCompleteFile;
//# sourceMappingURL=generate-complete-file.js.map